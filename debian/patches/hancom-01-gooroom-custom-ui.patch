diff --git a/configure.ac b/configure.ac
index 7bbcab8..dd3d1d9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -72,6 +72,9 @@ AC_SUBST(GETTEXT_PACKAGE)
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"$GETTEXT_PACKAGE",
                    [The gettext translation domain])
 
+AC_DEFINE_UNQUOTED(GOOROOM_PATH,"/usr/share/gooroom-yelp-adjustments/.yelp",
+                   [The Gooroom yelp resource path])
+
 AC_ARG_VAR([ITSTOOL], [Path to the `itstool` command])
 AC_CHECK_PROG([ITSTOOL], [itstool], [itstool])
 if test x"$ITSTOOL" = x; then
diff --git a/libyelp/yelp-docbook-document.c b/libyelp/yelp-docbook-document.c
index a511e9f..87b90d7 100644
--- a/libyelp/yelp-docbook-document.c
+++ b/libyelp/yelp-docbook-document.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2003-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2003-2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -94,6 +94,9 @@ static void           transform_error           (YelpTransform        *transform
 static void           transform_finalized       (YelpDocbookDocument  *docbook,
                                                  gpointer              transform);
 
+G_DEFINE_TYPE (YelpDocbookDocument, yelp_docbook_document, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_DOCBOOK_DOCUMENT, YelpDocbookDocumentPrivate))
+
 typedef struct _YelpDocbookDocumentPrivate  YelpDocbookDocumentPrivate;
 struct _YelpDocbookDocumentPrivate {
     DocbookState   state;
@@ -126,8 +129,6 @@ struct _YelpDocbookDocumentPrivate {
     GHashTable   *autoids;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpDocbookDocument, yelp_docbook_document, YELP_TYPE_DOCUMENT)
-
 /******************************************************************************/
 
 static void
@@ -154,12 +155,14 @@ yelp_docbook_document_class_init (YelpDocbookDocumentClass *klass)
 
     document_class->index = docbook_index;
     document_class->request_page = docbook_request_page;
+
+    g_type_class_add_private (klass, sizeof (YelpDocbookDocumentPrivate));
 }
 
 static void
 yelp_docbook_document_init (YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
 
     priv->state = DOCBOOK_STATE_BLANK;
     priv->autoids = NULL;
@@ -171,8 +174,7 @@ static void
 yelp_docbook_document_dispose (GObject *object)
 {
     gint i;
-    YelpDocbookDocumentPrivate *priv =
-        yelp_docbook_document_get_instance_private (YELP_DOCBOOK_DOCUMENT (object));
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->monitors != NULL) {
         for (i = 0; priv->monitors[i]; i++) {
@@ -188,8 +190,7 @@ yelp_docbook_document_dispose (GObject *object)
 static void
 yelp_docbook_document_finalize (GObject *object)
 {
-    YelpDocbookDocumentPrivate *priv =
-        yelp_docbook_document_get_instance_private (YELP_DOCBOOK_DOCUMENT (object));
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->xmldoc)
         xmlFreeDoc (priv->xmldoc);
@@ -220,7 +221,7 @@ yelp_docbook_document_new (YelpUri *uri)
     docbook = (YelpDocbookDocument *) g_object_new (YELP_TYPE_DOCBOOK_DOCUMENT,
                                                     "document-uri", uri,
                                                     NULL);
-    priv = yelp_docbook_document_get_instance_private (docbook);
+    priv = GET_PRIV (docbook);
 
     path = yelp_uri_get_search_path (uri);
     priv->monitors = g_new0 (GFileMonitor*, g_strv_length (path) + 1);
@@ -255,8 +256,7 @@ docbook_request_page (YelpDocument         *document,
                       gpointer              user_data,
                       GDestroyNotify        notify)
 {
-    YelpDocbookDocumentPrivate *priv =
-        yelp_docbook_document_get_instance_private (YELP_DOCBOOK_DOCUMENT (document));
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (document);
     gchar *docuri;
     GError *error;
     gboolean handled;
@@ -317,7 +317,7 @@ docbook_request_page (YelpDocument         *document,
 static void
 docbook_process (YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     YelpDocument *document = YELP_DOCUMENT (docbook);
     GFile *file = NULL;
     gchar *filepath = NULL;
@@ -473,7 +473,7 @@ docbook_process (YelpDocbookDocument *docbook)
 static void
 docbook_disconnect (YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     if (priv->chunk_ready) {
         g_signal_handler_disconnect (priv->transform, priv->chunk_ready);
         priv->chunk_ready = 0;
@@ -495,7 +495,7 @@ docbook_disconnect (YelpDocbookDocument *docbook)
 static gboolean
 docbook_reload (YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
 
     if (priv->index_running || priv->process_running || priv->transform_running)
         return TRUE;
@@ -525,7 +525,7 @@ docbook_monitor_changed   (GFileMonitor         *monitor,
                            GFileMonitorEvent     event_type,
                            YelpDocbookDocument  *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
 
     if (g_get_monotonic_time() - priv->reload_time < 1000)
         return;
@@ -550,7 +550,7 @@ docbook_walk (YelpDocbookDocument *docbook)
     xmlChar     *keywords = NULL;
     xmlNodePtr   cur, old_cur;
     gboolean chunkQ;
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     YelpDocument *document = YELP_DOCUMENT (docbook);
 
     debug_print (DB_FUNCTION, "entering\n");
@@ -856,7 +856,7 @@ transform_chunk_ready (YelpTransform       *transform,
                        gchar               *chunk_id,
                        YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     gchar *content;
 
     debug_print (DB_FUNCTION, "entering\n");
@@ -883,7 +883,7 @@ static void
 transform_finished (YelpTransform       *transform,
                     YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     YelpDocument *document = YELP_DOCUMENT (docbook);
     gchar *docuri;
     GError *error;
@@ -919,7 +919,7 @@ static void
 transform_error (YelpTransform       *transform,
                  YelpDocbookDocument *docbook)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
     GError *error;
 
     debug_print (DB_FUNCTION, "entering\n");
@@ -941,7 +941,7 @@ static void
 transform_finalized (YelpDocbookDocument *docbook,
                      gpointer             transform)
 {
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
 
     debug_print (DB_FUNCTION, "entering\n");
 
@@ -1010,7 +1010,7 @@ docbook_index_chunk (DocbookIndexData *index)
     gchar *title = NULL;
     gchar *keywords;
     GSList *chunks = NULL;
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (index->docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (index->docbook);
 
     id = xmlGetProp (index->cur, BAD_CAST "id");
     if (!id)
@@ -1095,7 +1095,7 @@ docbook_index_threaded (YelpDocbookDocument *docbook)
     GFile *file = NULL;
     gchar *filename = NULL;
     YelpUri *uri;
-    YelpDocbookDocumentPrivate *priv = yelp_docbook_document_get_instance_private (docbook);
+    YelpDocbookDocumentPrivate *priv = GET_PRIV (docbook);
 
     uri = yelp_document_get_uri (YELP_DOCUMENT (docbook));
     file = yelp_uri_get_file (uri);
@@ -1156,7 +1156,7 @@ docbook_index (YelpDocument *document)
     if (done)
         return;
 
-    priv = yelp_docbook_document_get_instance_private (YELP_DOCBOOK_DOCUMENT (document));
+    priv = GET_PRIV (document);
     g_object_ref (document);
     priv->index = g_thread_new ("docbook-index",
                                 (GThreadFunc)(GCallback) docbook_index_threaded,
diff --git a/libyelp/yelp-document.c b/libyelp/yelp-document.c
index fb340eb..ac3aa9f 100644
--- a/libyelp/yelp-document.c
+++ b/libyelp/yelp-document.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2003-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2003-2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -68,7 +68,7 @@ struct _Hash {
     GDestroyNotify  destroy;
 };
 
-struct _YelpDocumentPrivate {
+struct _YelpDocumentPriv {
     GMutex  mutex;
 
     GSList *reqs_all;         /* Holds canonical refs, only free from here */
@@ -101,7 +101,9 @@ struct _YelpDocumentPrivate {
     GError *idle_error;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpDocument, yelp_document, G_TYPE_OBJECT)
+G_DEFINE_TYPE (YelpDocument, yelp_document, G_TYPE_OBJECT)
+
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_DOCUMENT, YelpDocumentPriv))
 
 static void           yelp_document_dispose     (GObject              *object);
 static void           yelp_document_finalize    (GObject              *object);
@@ -294,14 +296,16 @@ yelp_document_class_init (YelpDocumentClass *klass)
                                                           YELP_TYPE_URI,
                                                           G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE |
                                                           G_PARAM_STATIC_STRINGS));
+
+    g_type_class_add_private (klass, sizeof (YelpDocumentPriv));
 }
 
 static void
 yelp_document_init (YelpDocument *document)
 {
-    YelpDocumentPrivate *priv;
+    YelpDocumentPriv *priv;
 
-    document->priv = priv = yelp_document_get_instance_private (document);
+    document->priv = priv = GET_PRIV (document);
 
     g_mutex_init (&priv->mutex);
 
@@ -1244,7 +1248,7 @@ yelp_document_signal (YelpDocument       *document,
 static gboolean
 yelp_document_error_pending_idle (YelpDocument *document)
 {
-    YelpDocumentPrivate *priv = yelp_document_get_instance_private (document);
+    YelpDocumentPriv *priv = GET_PRIV (document);
     GSList *cur;
     Request *request;
 
@@ -1272,7 +1276,7 @@ void
 yelp_document_error_pending (YelpDocument *document,
 			     const GError *error)
 {
-    YelpDocumentPrivate *priv = yelp_document_get_instance_private (document);
+    YelpDocumentPriv *priv = GET_PRIV (document);
 
     g_assert (document != NULL && YELP_IS_DOCUMENT (document));
 
@@ -1414,7 +1418,7 @@ static gboolean
 request_idle_contents (Request *request)
 {
     YelpDocument *document;
-    YelpDocumentPrivate *priv;
+    YelpDocumentPriv *priv;
     YelpDocumentCallback callback = NULL;
     gpointer user_data;
 
@@ -1426,7 +1430,7 @@ request_idle_contents (Request *request)
     }
 
     document = g_object_ref (request->document);
-    priv = yelp_document_get_instance_private (document);
+    priv = GET_PRIV (document);
 
     g_mutex_lock (&document->priv->mutex);
 
@@ -1480,7 +1484,7 @@ static gboolean
 request_idle_error (Request *request)
 {
     YelpDocument *document;
-    YelpDocumentPrivate *priv;
+    YelpDocumentPriv *priv;
     YelpDocumentCallback callback = NULL;
     GError *error = NULL;
     gpointer user_data;
@@ -1493,7 +1497,7 @@ request_idle_error (Request *request)
     }
 
     document = g_object_ref (request->document);
-    priv = yelp_document_get_instance_private (document);
+    priv = GET_PRIV (document);
 
     g_mutex_lock (&priv->mutex);
 
diff --git a/libyelp/yelp-document.h b/libyelp/yelp-document.h
index d4db68c..8ee9203 100644
--- a/libyelp/yelp-document.h
+++ b/libyelp/yelp-document.h
@@ -35,9 +35,9 @@ G_BEGIN_DECLS
 #define YELP_IS_DOCUMENT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), YELP_TYPE_DOCUMENT))
 #define YELP_DOCUMENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), YELP_TYPE_DOCUMENT, YelpDocumentClass))
 
-typedef struct _YelpDocument         YelpDocument;
-typedef struct _YelpDocumentClass    YelpDocumentClass;
-typedef struct _YelpDocumentPrivate  YelpDocumentPrivate;
+typedef struct _YelpDocument      YelpDocument;
+typedef struct _YelpDocumentClass YelpDocumentClass;
+typedef struct _YelpDocumentPriv  YelpDocumentPriv;
 
 typedef enum {
     YELP_DOCUMENT_SIGNAL_CONTENTS,
@@ -51,8 +51,8 @@ typedef void      (*YelpDocumentCallback)      (YelpDocument         *document,
                                                 GError               *error);
 
 struct _YelpDocument {
-    GObject              parent;
-    YelpDocumentPrivate *priv;
+    GObject           parent;
+    YelpDocumentPriv *priv;
 };
 
 struct _YelpDocumentClass {
diff --git a/libyelp/yelp-help-list.c b/libyelp/yelp-help-list.c
index 03cfeb2..4b81e7d 100644
--- a/libyelp/yelp-help-list.c
+++ b/libyelp/yelp-help-list.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2010-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2010 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -30,6 +30,7 @@
 #include <libxml/xinclude.h>
 #include <libxml/xpath.h>
 #include <libxml/xpathInternals.h>
+#include <libxml/HTMLparser.h>
 
 #include "yelp-help-list.h"
 #include "yelp-settings.h"
@@ -56,22 +57,14 @@ static void           help_list_process_docbook      (YelpHelpList          *lis
                                                       HelpListEntry         *entry);
 static void           help_list_process_mallard      (YelpHelpList          *list,
                                                       HelpListEntry         *entry);
+static void           help_list_process_html      (YelpHelpList          *list,
+                                                      HelpListEntry         *entry);
 
 static const char*const known_vendor_prefixes[] = { "gnome",
                                                     "fedora",
                                                     "mozilla",
                                                     NULL };
 
-struct _HelpListEntry
-{
-    gchar *id;
-    gchar *title;
-    gchar *desc;
-    gchar *icon;
-
-    gchar *filename;
-    YelpUriDocumentType type;
-};
 static void
 help_list_entry_free (HelpListEntry *entry)
 {
@@ -89,6 +82,9 @@ help_list_entry_cmp (HelpListEntry *a, HelpListEntry *b)
     return g_utf8_collate (as, bs);
 }
 
+G_DEFINE_TYPE (YelpHelpList, yelp_help_list, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_HELP_LIST, YelpHelpListPrivate))
+
 typedef struct _YelpHelpListPrivate  YelpHelpListPrivate;
 struct _YelpHelpListPrivate {
     GMutex         mutex;
@@ -107,10 +103,9 @@ struct _YelpHelpListPrivate {
     xmlXPathCompExprPtr  get_docbook_title;
     xmlXPathCompExprPtr  get_mallard_title;
     xmlXPathCompExprPtr  get_mallard_desc;
+    xmlXPathCompExprPtr  get_html_title;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpHelpList, yelp_help_list, YELP_TYPE_DOCUMENT)
-
 static void
 yelp_help_list_class_init (YelpHelpListClass *klass)
 {
@@ -121,12 +116,14 @@ yelp_help_list_class_init (YelpHelpListClass *klass)
     object_class->finalize = yelp_help_list_finalize;
 
     document_class->request_page = help_list_request_page;
+
+    g_type_class_add_private (klass, sizeof (YelpHelpListPrivate));
 }
 
 static void
 yelp_help_list_init (YelpHelpList *list)
 {
-    YelpHelpListPrivate *priv = yelp_help_list_get_instance_private (list);
+    YelpHelpListPrivate *priv = GET_PRIV (list);
 
     g_mutex_init (&priv->mutex);
     /* don't free the key, it belongs to the value struct */
@@ -143,6 +140,7 @@ yelp_help_list_init (YelpHelpList *list)
     priv->get_mallard_title = xmlXPathCompile (BAD_CAST "normalize-space((/mal:page/mal:info/mal:title[@type='text'] |"
                                                "                 /mal:page/mal:title)[1])");
     priv->get_mallard_desc = xmlXPathCompile (BAD_CAST "normalize-space(/mal:page/mal:info/mal:desc[1])");
+    priv->get_html_title = xmlXPathCompile (BAD_CAST "normalize-space(/html:HEAD//html:title)");
 
     yelp_document_set_page_id ((YelpDocument *) list, NULL, "index");
     yelp_document_set_page_id ((YelpDocument *) list, "index", "index");
@@ -157,7 +155,7 @@ yelp_help_list_dispose (GObject *object)
 static void
 yelp_help_list_finalize (GObject *object)
 {
-    YelpHelpListPrivate *priv = yelp_help_list_get_instance_private (YELP_HELP_LIST (object));
+    YelpHelpListPrivate *priv = GET_PRIV (object);
 
     /* entry structs belong to hash table */
     g_list_free (priv->all_entries);
@@ -175,6 +173,8 @@ yelp_help_list_finalize (GObject *object)
         xmlXPathFreeCompExpr (priv->get_mallard_title);
     if (priv->get_mallard_desc)
         xmlXPathFreeCompExpr (priv->get_mallard_desc);
+    if (priv->get_html_title)
+        xmlXPathFreeCompExpr (priv->get_html_title);
 
     g_clear_object (&priv->transform);
 
@@ -205,7 +205,7 @@ help_list_request_page (YelpDocument          *document,
                         GDestroyNotify         notify)
 {
     gboolean handled;
-    YelpHelpListPrivate *priv = yelp_help_list_get_instance_private (YELP_HELP_LIST (document));
+    YelpHelpListPrivate *priv = GET_PRIV (document);
 
     if (page_id == NULL)
         page_id = "index";
@@ -239,6 +239,216 @@ help_list_request_page (YelpDocument          *document,
     return TRUE;
 }
 
+GList *
+help_list_get_all_entries (YelpDocument *list)
+{
+    YelpHelpListPrivate *priv = GET_PRIV (list);
+    return priv->all_entries;
+}
+
+void
+help_list_entries_init (YelpHelpList *list)
+{
+    const gchar * const *sdatadirs = g_get_system_data_dirs ();
+    const gchar * const *langs = g_get_language_names ();
+
+    YelpHelpListPrivate *priv = GET_PRIV (list);
+    /* The strings are still owned by GLib; we just own the array. */
+    gchar **datadirs;
+    gint datadir_i, lang_i;
+
+    gboolean is_ko = FALSE;
+    gboolean gr_adjustments = FALSE;
+
+    gr_adjustments = g_file_test (GOOROOM_PATH, G_FILE_TEST_EXISTS);
+
+    for (lang_i = 0; langs[lang_i]; lang_i++) {
+        if (g_strcmp0 (langs[lang_i], "ko") == 0) {
+            is_ko = TRUE;
+            break;
+        }
+    }
+
+    datadirs = g_new0 (gchar *, g_strv_length ((gchar **) sdatadirs) + 2);
+    datadirs[0] = (gchar *) g_get_user_data_dir ();
+    for (datadir_i = 0; sdatadirs[datadir_i]; datadir_i++) {
+        datadirs[datadir_i + 1] = (gchar *) sdatadirs[datadir_i];
+    }
+
+    if (!is_ko || (!gr_adjustments && is_ko)) {
+        for (datadir_i = 0; datadirs[datadir_i]; datadir_i++) {
+            gchar *helpdirname = g_build_filename (datadirs[datadir_i], "gnome", "help", NULL);
+            GFile *helpdir = g_file_new_for_path (helpdirname);
+            GFileEnumerator *children = g_file_enumerate_children (helpdir,
+                                                                   G_FILE_ATTRIBUTE_STANDARD_TYPE","
+                                                                   G_FILE_ATTRIBUTE_STANDARD_NAME,
+                                                                   G_FILE_QUERY_INFO_NONE,
+                                                                   NULL, NULL);
+            GFileInfo *child;
+            if (children == NULL) {
+                g_object_unref (helpdir);
+                g_free (helpdirname);
+                continue;
+            }
+            while ((child = g_file_enumerator_next_file (children, NULL, NULL))) {
+                gchar *docid;
+                HelpListEntry *entry = NULL;
+
+                if (g_file_info_get_file_type (child) != G_FILE_TYPE_DIRECTORY) {
+                    g_object_unref (child);
+                    continue;
+                }
+
+                docid = g_strconcat ("ghelp:", g_file_info_get_name (child), NULL);
+                if (g_hash_table_lookup (priv->entries, docid)) {
+                    g_free (docid);
+                    g_object_unref (child);
+                    continue;
+                }
+
+                for (lang_i = 0; langs[lang_i]; lang_i++) {
+                    gchar *filename, *tmp;
+
+                    filename = g_build_filename (helpdirname,
+                                                g_file_info_get_name (child),
+                                                langs[lang_i],
+                                                "index.page",
+                                                 NULL);
+                    if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+                        entry = g_new0 (HelpListEntry, 1);
+                        entry->id = g_strdup (docid);
+                        entry->filename = filename;
+                        entry->type = YELP_URI_DOCUMENT_TYPE_MALLARD;
+                        break;
+                    }
+                    g_free (filename);
+
+                    tmp = g_strdup_printf ("%s.xml", g_file_info_get_name (child));
+                    filename = g_build_filename (helpdirname,
+                                                 g_file_info_get_name (child),
+                                                 langs[lang_i],
+                                                 tmp,
+                                                 NULL);
+                    g_free (tmp);
+                    if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+                        entry = g_new0 (HelpListEntry, 1);
+                        entry->id = g_strdup (docid);
+                        entry->filename = filename;
+                        entry->type = YELP_URI_DOCUMENT_TYPE_DOCBOOK;
+                        break;
+                    }
+                    g_free (filename);
+                }
+
+                if (entry != NULL) {
+                    g_hash_table_insert (priv->entries, docid, entry);
+                    priv->all_entries = g_list_prepend (priv->all_entries, entry);
+                }
+                else
+                    g_free (docid);
+                g_object_unref (child);
+            }
+            g_object_unref (children);
+            g_object_unref (helpdir);
+            g_free (helpdirname);
+        }
+    }
+    for (datadir_i = 0; datadirs[datadir_i]; datadir_i++) {
+        for (lang_i = 0; langs[lang_i]; lang_i++) {
+            if (gr_adjustments && is_ko &&
+                (g_strcmp0 (langs[lang_i], "ko") != 0))
+                continue;
+            gchar *langdirname = g_build_filename (datadirs[datadir_i], "help", langs[lang_i], NULL);
+            GFile *langdir = g_file_new_for_path (langdirname);
+            GFileEnumerator *children = g_file_enumerate_children (langdir,
+                                                                   G_FILE_ATTRIBUTE_STANDARD_TYPE","
+                                                                   G_FILE_ATTRIBUTE_STANDARD_NAME,
+                                                                   G_FILE_QUERY_INFO_NONE,
+                                                                   NULL, NULL);
+            GFileInfo *child;
+            if (children == NULL) {
+                g_object_unref (langdir);
+                g_free (langdirname);
+                continue;
+            }
+            while ((child = g_file_enumerator_next_file (children, NULL, NULL))) {
+                gchar *docid, *filename;
+                HelpListEntry *entry = NULL;
+                if (g_file_info_get_file_type (child) != G_FILE_TYPE_DIRECTORY) {
+                    g_object_unref (child);
+                    continue;
+                }
+
+                docid = g_strconcat ("help:", g_file_info_get_name (child), NULL);
+                if (g_hash_table_lookup (priv->entries, docid) != NULL) {
+                    g_free (docid);
+                    continue;
+                }
+
+                filename = g_build_filename (langdirname,
+                                            g_file_info_get_name (child),
+                                            "index.page",
+                                             NULL);
+                if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+                    entry = g_new0 (HelpListEntry, 1);
+                    entry->id = docid;
+                    entry->filename = filename;
+                    entry->type = YELP_URI_DOCUMENT_TYPE_MALLARD;
+                    goto found;
+                }
+                g_free (filename);
+
+                filename = g_build_filename (langdirname,
+                                            g_file_info_get_name (child),
+                                            "index.docbook",
+                                             NULL);
+                if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+                    entry = g_new0 (HelpListEntry, 1);
+                    entry->id = docid;
+                    entry->filename = filename;
+                    entry->type = YELP_URI_DOCUMENT_TYPE_DOCBOOK;
+                    goto found;
+                }
+                g_free (filename);
+
+                filename = g_build_filename (langdirname,
+                                             g_file_info_get_name (child),
+                                             "index.html",
+                                             NULL);
+                if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+                    entry = g_new0 (HelpListEntry, 1);
+                    entry->id = docid;
+                    entry->filename = filename;
+                    entry->type = YELP_URI_DOCUMENT_TYPE_HTML;
+                    goto found;                   
+                }
+
+                g_free (docid);
+            found:
+                g_object_unref (child);
+                if (entry != NULL) {
+                    g_hash_table_insert (priv->entries, docid, entry);
+                    priv->all_entries = g_list_prepend (priv->all_entries, entry);
+                }
+
+                if (entry->type == YELP_URI_DOCUMENT_TYPE_MALLARD)
+                    help_list_process_mallard (list, entry);
+                else if (entry->type == YELP_URI_DOCUMENT_TYPE_DOCBOOK)
+                    help_list_process_docbook (list, entry);
+                else if (entry->type == YELP_URI_DOCUMENT_TYPE_HTML)
+                    help_list_process_html (list, entry);
+
+            }
+
+            g_object_unref (children);
+        }
+    }
+
+    priv->all_entries = g_list_sort (priv->all_entries,
+                                     (GCompareFunc) help_list_entry_cmp);
+    g_free (datadirs);
+}
+
 static void
 help_list_think (YelpHelpList *list)
 {
@@ -251,6 +461,8 @@ help_list_think (YelpHelpList *list)
     GList *cur;
     GtkIconTheme *theme;
 
+	help_list_entries_init (list);
+
     datadirs = g_new0 (gchar *, g_strv_length ((gchar **) sdatadirs) + 2);
     datadirs[0] = (gchar *) g_get_user_data_dir ();
     for (datadir_i = 0; sdatadirs[datadir_i]; datadir_i++)
@@ -397,75 +609,25 @@ help_list_think (YelpHelpList *list)
                 else {
                     g_free (docid);
                 }
-            }
-
-            g_object_unref (children);
-        }
-    }
-    g_free (datadirs);
 
-    theme = gtk_icon_theme_get_default ();
-    for (cur = priv->all_entries; cur != NULL; cur = cur->next) {
-        GDesktopAppInfo *app;
-        gchar *tmp;
-        HelpListEntry *entry = (HelpListEntry *) cur->data;
-        const gchar *entryid = strchr (entry->id, ':') + 1;
+                if (entry->type == YELP_URI_DOCUMENT_TYPE_MALLARD)
+                    help_list_process_mallard (list, entry);
+                else if (entry->type == YELP_URI_DOCUMENT_TYPE_DOCBOOK)
+                    help_list_process_docbook (list, entry);
+                else if (entry->type == YELP_URI_DOCUMENT_TYPE_HTML)
+                    help_list_process_html (list, entry);
 
-        if (entry->type == YELP_URI_DOCUMENT_TYPE_MALLARD)
-            help_list_process_mallard (list, entry);
-        else if (entry->type == YELP_URI_DOCUMENT_TYPE_DOCBOOK)
-            help_list_process_docbook (list, entry);
-
-        if (g_str_equal (entryid, "gnome-terminal")) {
-            tmp = g_strconcat ("org.gnome.Terminal", ".desktop", NULL);
-        }
-        else {
-            tmp = g_strconcat (entryid, ".desktop", NULL);
-        }
-        app = g_desktop_app_info_new (tmp);
-        g_free (tmp);
-
-        if (app == NULL) {
-            char **prefix;
-            for (prefix = (char **) known_vendor_prefixes; *prefix; prefix++) {
-                tmp = g_strconcat (*prefix, "-", entryid, ".desktop", NULL);
-                app = g_desktop_app_info_new (tmp);
-                g_free (tmp);
-                if (app)
-                    break;
             }
-        }
 
-        if (app != NULL) {
-            GIcon *icon = g_app_info_get_icon ((GAppInfo *) app);
-            if (icon != NULL) {
-                GtkIconInfo *info = gtk_icon_theme_lookup_by_gicon (theme, icon, 48, 0);
-                if (info != NULL) {
-                    const gchar *iconfile = gtk_icon_info_get_filename (info);
-                    if (iconfile)
-                        entry->icon = g_filename_to_uri (iconfile, NULL, NULL);
-                    g_object_unref (info);
-                }
-            }
-            g_object_unref (app);
+            g_object_unref (children);
         }
     }
 
-    g_mutex_lock (&priv->mutex);
-    priv->process_running = FALSE;
-    priv->process_ran = TRUE;
-    while (priv->pending) {
-        gchar *page_id = (gchar *) priv->pending->data;
-        help_list_handle_page (list, page_id);
-        g_free (page_id);
-        priv->pending = g_slist_delete_link (priv->pending, priv->pending);
-    }
-    g_mutex_unlock (&priv->mutex);
-
-    g_object_unref (list);
+    priv->all_entries = g_list_sort (priv->all_entries,
+                                     (GCompareFunc) help_list_entry_cmp);
+    g_free (datadirs);
 }
 
-
 static void
 help_list_reload (YelpHelpList *list)
 {
@@ -610,7 +772,7 @@ help_list_process_mallard (YelpHelpList  *list,
     xmlDocPtr xmldoc;
     xmlXPathContextPtr xpath;
     xmlXPathObjectPtr obj = NULL;
-    YelpHelpListPrivate *priv = yelp_help_list_get_instance_private (list);
+    YelpHelpListPrivate *priv = GET_PRIV (list);
 
     parserCtxt = xmlNewParserCtxt ();
     xmldoc = xmlCtxtReadFile (parserCtxt,
@@ -648,3 +810,68 @@ help_list_process_mallard (YelpHelpList  *list,
     if (xpath)
         xmlXPathFreeContext (xpath);
 }
+
+static gchar*
+help_list_get_html_title (xmlNode *root)
+{
+    xmlNode *node = NULL;
+    xmlAttr *attr = NULL;
+    gchar   *value = NULL;
+
+    for (node = root; node; node = node->next) {
+        attr = node->properties;
+
+        while (attr && attr->name && attr->children) {
+            /* find id attribute */
+            if (0 == g_strcmp0 ((gchar *)(attr->name), "id")) {
+                gchar *at = (gchar *)xmlNodeListGetString (node->doc, attr->children, 1);
+                /* if id content is title... */
+                if (0 == g_strcmp0(at, "title")) {
+                    value = (gchar*)xmlNodeGetContent (node);
+
+                    g_free (at);
+                    return value;
+                }
+                g_free (at);
+            }
+            attr = attr->next;
+        }
+
+        value = help_list_get_html_title (node->children);
+        if (value)
+            break;
+    }
+
+    return value;
+}
+
+static void
+help_list_process_html (YelpHelpList  *list,
+                        HelpListEntry *entry)
+{
+    htmlDocPtr doc;
+    xmlNode *root = NULL;
+    doc = htmlReadFile ((const char *)entry->filename, NULL,
+                        HTML_PARSE_NOBLANKS |
+                        HTML_PARSE_NOERROR | 
+                        HTML_PARSE_NOWARNING | 
+                        HTML_PARSE_NONET);
+
+    if (!doc)
+        return;
+
+    root = xmlDocGetRootElement (doc);
+    if (root == NULL) {
+        xmlFreeDoc (doc);
+        return;
+    }
+
+    entry->title = help_list_get_html_title (root->children);
+
+    if (doc)
+        xmlFreeDoc (doc);
+
+    xmlCleanupParser ();
+
+    return;
+}
diff --git a/libyelp/yelp-help-list.h b/libyelp/yelp-help-list.h
index 07773c0..5aa73f9 100644
--- a/libyelp/yelp-help-list.h
+++ b/libyelp/yelp-help-list.h
@@ -34,6 +34,18 @@
 
 typedef struct _YelpHelpList      YelpHelpList;
 typedef struct _YelpHelpListClass YelpHelpListClass;
+typedef struct _HelpListEntry     HelpListEntry;
+
+struct _HelpListEntry
+{
+    gchar *id;
+    gchar *title;
+    gchar *desc;
+    gchar *icon;
+
+    gchar *filename;
+    YelpUriDocumentType type;
+};
 
 struct _YelpHelpList {
     YelpDocument      parent;
@@ -45,5 +57,7 @@ struct _YelpHelpListClass {
 
 GType           yelp_help_list_get_type     (void);
 YelpDocument *  yelp_help_list_new          (YelpUri *uri);
+GList *         help_list_get_all_entries   (YelpDocument *list);
+void            help_list_entries_init      (YelpHelpList *list);
 
 #endif /* __YELP_HELP_LIST_H__ */
diff --git a/libyelp/yelp-info-document.c b/libyelp/yelp-info-document.c
index 0f89f66..d55be32 100644
--- a/libyelp/yelp-info-document.c
+++ b/libyelp/yelp-info-document.c
@@ -1,7 +1,7 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
  * Copyright (C) 2007 Don Scorgie <dscorgie@svn.gnome.org>
- * Copyright (C) 2010-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2010 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -66,7 +66,6 @@ struct _YelpInfoDocumentPrivate {
     gchar   *visit_prev_id;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpInfoDocument, yelp_info_document, YELP_TYPE_DOCUMENT)
 
 static void           yelp_info_document_dispose          (GObject                *object);
 static void           yelp_info_document_finalize         (GObject                *object);
@@ -98,6 +97,9 @@ static gboolean       info_sections_visit       (GtkTreeModel         *model,
 static void           info_document_disconnect  (YelpInfoDocument     *info);
 
 
+G_DEFINE_TYPE (YelpInfoDocument, yelp_info_document, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_INFO_DOCUMENT, YelpInfoDocumentPrivate))
+
 static void
 yelp_info_document_class_init (YelpInfoDocumentClass *klass)
 {
@@ -108,12 +110,14 @@ yelp_info_document_class_init (YelpInfoDocumentClass *klass)
     object_class->finalize = yelp_info_document_finalize;
 
     document_class->request_page = info_request_page;
+
+    g_type_class_add_private (klass, sizeof (YelpInfoDocumentPrivate));
 }
 
 static void
 yelp_info_document_init (YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
 
     priv->state = INFO_STATE_BLANK;
     priv->xmldoc = NULL;
@@ -123,8 +127,7 @@ yelp_info_document_init (YelpInfoDocument *info)
 static void
 yelp_info_document_dispose (GObject *object)
 {
-    YelpInfoDocumentPrivate *priv =
-        yelp_info_document_get_instance_private (YELP_INFO_DOCUMENT (object));
+    YelpInfoDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->sections) {
         g_object_unref (priv->sections);
@@ -142,8 +145,7 @@ yelp_info_document_dispose (GObject *object)
 static void
 yelp_info_document_finalize (GObject *object)
 {
-    YelpInfoDocumentPrivate *priv =
-        yelp_info_document_get_instance_private (YELP_INFO_DOCUMENT (object));
+    YelpInfoDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->xmldoc)
         xmlFreeDoc (priv->xmldoc);
@@ -180,8 +182,7 @@ info_request_page (YelpDocument         *document,
                    gpointer              user_data,
                    GDestroyNotify        notify)
 {
-    YelpInfoDocumentPrivate *priv =
-        yelp_info_document_get_instance_private (YELP_INFO_DOCUMENT (document));
+    YelpInfoDocumentPrivate *priv = GET_PRIV (document);
     gchar *docuri;
     GError *error;
     gboolean handled;
@@ -243,7 +244,7 @@ transform_chunk_ready (YelpTransform    *transform,
                        gchar            *chunk_id,
                        YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     gchar *content;
 
     g_assert (transform == priv->transform);
@@ -273,7 +274,7 @@ static void
 transform_finished (YelpTransform    *transform,
                     YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     gchar *docuri;
     GError *error;
 
@@ -308,7 +309,7 @@ static void
 transform_error (YelpTransform    *transform,
                  YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     GError *error;
 
     g_assert (transform == priv->transform);
@@ -329,7 +330,7 @@ static void
 transform_finalized (YelpInfoDocument *info,
                      gpointer          transform)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
  
     if (priv->xmldoc)
 	xmlFreeDoc (priv->xmldoc);
@@ -344,7 +345,7 @@ transform_finalized (YelpInfoDocument *info,
 static void
 info_document_process (YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     GFile *file = NULL;
     gchar *filepath = NULL;
     GError *error;
@@ -428,7 +429,7 @@ info_sections_visit (GtkTreeModel     *model,
                      GtkTreeIter      *iter,
                      YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     gchar *page_id, *title;
 
     gtk_tree_model_get (model, iter,
@@ -457,7 +458,7 @@ info_sections_visit (GtkTreeModel     *model,
 static void
 info_document_disconnect (YelpInfoDocument *info)
 {
-    YelpInfoDocumentPrivate *priv = yelp_info_document_get_instance_private (info);
+    YelpInfoDocumentPrivate *priv = GET_PRIV (info);
     if (priv->chunk_ready) {
         g_signal_handler_disconnect (priv->transform, priv->chunk_ready);
         priv->chunk_ready = 0;
diff --git a/libyelp/yelp-mallard-document.c b/libyelp/yelp-mallard-document.c
index 435ec51..f419301 100644
--- a/libyelp/yelp-mallard-document.c
+++ b/libyelp/yelp-mallard-document.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2009-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -116,6 +116,9 @@ static gboolean       xml_node_is_ns_name       (xmlNodePtr            node,
                                                  const xmlChar        *name);
 
 
+G_DEFINE_TYPE (YelpMallardDocument, yelp_mallard_document, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_MALLARD_DOCUMENT, YelpMallardDocumentPrivate))
+
 typedef struct _YelpMallardDocumentPrivate  YelpMallardDocumentPrivate;
 struct _YelpMallardDocumentPrivate {
     MallardState   state;
@@ -137,8 +140,6 @@ struct _YelpMallardDocumentPrivate {
     xmlXPathCompExprPtr  normalize;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpMallardDocument, yelp_mallard_document, YELP_TYPE_DOCUMENT)
-
 /******************************************************************************/
 
 static void
@@ -152,12 +153,14 @@ yelp_mallard_document_class_init (YelpMallardDocumentClass *klass)
 
     document_class->request_page = mallard_request_page;
     document_class->index = mallard_index;
+
+    g_type_class_add_private (klass, sizeof (YelpMallardDocumentPrivate));
 }
 
 static void
 yelp_mallard_document_init (YelpMallardDocument *mallard)
 {
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (mallard);
     xmlNodePtr cur;
 
     g_mutex_init (&priv->mutex);
@@ -183,8 +186,7 @@ static void
 yelp_mallard_document_dispose (GObject *object)
 {
     gint i;
-    YelpMallardDocumentPrivate *priv =
-        yelp_mallard_document_get_instance_private (YELP_MALLARD_DOCUMENT (object));
+    YelpMallardDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->monitors != NULL) {
         for (i = 0; priv->monitors[i]; i++) {
@@ -200,8 +202,7 @@ yelp_mallard_document_dispose (GObject *object)
 static void
 yelp_mallard_document_finalize (GObject *object)
 {
-    YelpMallardDocumentPrivate *priv =
-        yelp_mallard_document_get_instance_private (YELP_MALLARD_DOCUMENT (object));
+    YelpMallardDocumentPrivate *priv = GET_PRIV (object);
 
     g_mutex_clear (&priv->mutex);
     g_hash_table_destroy (priv->pages_hash);
@@ -228,7 +229,7 @@ yelp_mallard_document_new (YelpUri *uri)
     mallard = (YelpMallardDocument *) g_object_new (YELP_TYPE_MALLARD_DOCUMENT,
                                                     "document-uri", uri,
                                                     NULL);
-    priv = yelp_mallard_document_get_instance_private (mallard);
+    priv = GET_PRIV (mallard);
 
     yelp_document_set_page_id ((YelpDocument *) mallard, NULL, "index");
     yelp_document_set_page_id ((YelpDocument *) mallard, "index", "index");
@@ -264,15 +265,13 @@ mallard_request_page (YelpDocument         *document,
                       gpointer              user_data,
                       GDestroyNotify        notify)
 {
-    YelpMallardDocumentPrivate *priv =
-        yelp_mallard_document_get_instance_private (YELP_MALLARD_DOCUMENT (document));
+    YelpMallardDocumentPrivate *priv = GET_PRIV (document);
     gchar *docuri;
     GError *error;
     gboolean handled;
 
     debug_print (DB_FUNCTION, "entering\n");
     debug_print (DB_ARG, "    page_id=\"%s\"\n", page_id);
-
     if (page_id == NULL)
         page_id = "index";
 
@@ -332,7 +331,7 @@ mallard_request_page (YelpDocument         *document,
 static void
 mallard_think (YelpMallardDocument *mallard)
 {
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (mallard);
     GError *error = NULL;
     gboolean editor_mode;
 
@@ -455,7 +454,7 @@ mallard_try_run (YelpMallardDocument *mallard,
                  const gchar         *page_id)
 {
     /* We expect to be in a locked mutex when this function is called. */
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (mallard);
     MallardPageData *page_data = NULL;
     gchar *real_id = NULL;
     GError *error;
@@ -520,7 +519,7 @@ mallard_page_data_cancel (MallardPageData *page_data)
 static void
 mallard_page_data_walk (MallardPageData *page_data)
 {
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (page_data->mallard);
     xmlParserCtxtPtr parserCtxt = NULL;
     xmlChar *id = NULL;
 
@@ -662,8 +661,7 @@ mallard_page_data_info (MallardPageData *page_data,
                 if (xmlStrEqual (type, BAD_CAST "sort"))
                     page_data->sort_title = TRUE;
                 if (xmlStrEqual (type, BAD_CAST "text")) {
-                    YelpMallardDocumentPrivate *priv =
-                        yelp_mallard_document_get_instance_private (page_data->mallard);
+                    YelpMallardDocumentPrivate *priv = GET_PRIV (page_data->mallard);
                     xmlXPathObjectPtr obj;
                     page_data->xpath->node = child;
                     obj = xmlXPathCompiledEval (priv->normalize, page_data->xpath);
@@ -677,7 +675,7 @@ mallard_page_data_info (MallardPageData *page_data,
             }
         }
         else if (xml_node_is_ns_name (child, MALLARD_NS, BAD_CAST "desc")) {
-            YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+            YelpMallardDocumentPrivate *priv = GET_PRIV (page_data->mallard);
             xmlXPathObjectPtr obj;
             page_data->xpath->node = child;
             obj = xmlXPathCompiledEval (priv->normalize, page_data->xpath);
@@ -690,7 +688,7 @@ mallard_page_data_info (MallardPageData *page_data,
         else if (xml_node_is_ns_name (child, MALLARD_NS, BAD_CAST "keywords")) {
             /* FIXME: multiple keywords? same for desc/title */
 
-            YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+            YelpMallardDocumentPrivate *priv = GET_PRIV (page_data->mallard);
             xmlXPathObjectPtr obj;
             page_data->xpath->node = child;
             obj = xmlXPathCompiledEval (priv->normalize, page_data->xpath);
@@ -735,7 +733,7 @@ static void
 mallard_page_data_run (MallardPageData *page_data)
 {
     YelpSettings *settings = yelp_settings_get_default ();
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (page_data->mallard);
     gchar **params = NULL;
 
     mallard_page_data_cancel (page_data);
@@ -804,7 +802,7 @@ transform_chunk_ready (YelpTransform   *transform,
               YELP_IS_MALLARD_DOCUMENT (page_data->mallard));
     g_assert (transform == page_data->transform);
 
-    priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+    priv = GET_PRIV (page_data->mallard);
 
     if (priv->state == MALLARD_STATE_STOP) {
         mallard_page_data_cancel (page_data);
@@ -833,7 +831,7 @@ transform_finished (YelpTransform   *transform,
               YELP_IS_MALLARD_DOCUMENT (page_data->mallard));
     g_assert (transform == page_data->transform);
 
-    priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+    priv = GET_PRIV (page_data->mallard);
 
     if (priv->state == MALLARD_STATE_STOP) {
         mallard_page_data_cancel (page_data);
@@ -858,7 +856,7 @@ transform_error (YelpTransform   *transform,
               YELP_IS_MALLARD_DOCUMENT (page_data->mallard));
     g_assert (transform == page_data->transform);
 
-    priv = yelp_mallard_document_get_instance_private (page_data->mallard);
+    priv = GET_PRIV (page_data->mallard);
 
     if (priv->state == MALLARD_STATE_STOP) {
         mallard_page_data_cancel (page_data);
@@ -1004,7 +1002,7 @@ mallard_index_threaded (YelpMallardDocument *mallard)
     GHashTable *ids;
     gchar *doc_uri;
     YelpUri *document_uri;
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (mallard);
 
     document_uri = yelp_document_get_uri (YELP_DOCUMENT (mallard));
     doc_uri = yelp_uri_get_document_uri (document_uri);
@@ -1139,7 +1137,7 @@ mallard_index (YelpDocument *document)
     if (done)
         return;
 
-    priv = yelp_mallard_document_get_instance_private (YELP_MALLARD_DOCUMENT (document));
+    priv = GET_PRIV (document);
     g_object_ref (document);
     priv->index = g_thread_new ("mallard-index",
                                 (GThreadFunc)(GCallback) mallard_index_threaded,
@@ -1174,7 +1172,7 @@ mallard_reload (YelpMallardDocument *mallard)
     gchar **ids;
     gint i;
     xmlNodePtr cur;
-    YelpMallardDocumentPrivate *priv = yelp_mallard_document_get_instance_private (mallard);
+    YelpMallardDocumentPrivate *priv = GET_PRIV (mallard);
 
     /* Exiting the thinking thread would require a fair amount of retooling.
        For now, we'll just fail to auto-reload if that's still happening.
@@ -1198,7 +1196,6 @@ mallard_reload (YelpMallardDocument *mallard)
     xmlFreeDoc (priv->cache);
     priv->cache = xmlNewDoc (BAD_CAST "1.0");
     priv->cache_ns = xmlNewNs (NULL, CACHE_NS, BAD_CAST "cache");
-    priv->mallard_ns = xmlNewNs (NULL, MALLARD_NS, BAD_CAST "mal");
     cur = xmlNewDocNode (priv->cache, priv->cache_ns, BAD_CAST "cache", NULL);
     xmlDocSetRootElement (priv->cache, cur);
     priv->cache_ns->next = priv->mallard_ns;
diff --git a/libyelp/yelp-man-document.c b/libyelp/yelp-man-document.c
index dba8a1d..a18248c 100644
--- a/libyelp/yelp-man-document.c
+++ b/libyelp/yelp-man-document.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2007-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2007-2010 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -61,8 +61,6 @@ struct _YelpManDocumentPrivate {
     guint          error;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpManDocument, yelp_man_document, YELP_TYPE_DOCUMENT)
-
 static void           yelp_man_document_finalize         (GObject                *object);
 
 /* YelpDocument */
@@ -90,6 +88,9 @@ static void           man_document_process               (YelpManDocument
 static void           man_document_disconnect            (YelpManDocument        *man);
 
 
+G_DEFINE_TYPE (YelpManDocument, yelp_man_document, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_MAN_DOCUMENT, YelpManDocumentPrivate))
+
 static void
 yelp_man_document_class_init (YelpManDocumentClass *klass)
 {
@@ -99,12 +100,14 @@ yelp_man_document_class_init (YelpManDocumentClass *klass)
     object_class->finalize = yelp_man_document_finalize;
 
     document_class->request_page = man_request_page;
+
+    g_type_class_add_private (klass, sizeof (YelpManDocumentPrivate));
 }
 
 static void
 yelp_man_document_init (YelpManDocument *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
 
     priv->state = MAN_STATE_BLANK;
     g_mutex_init (&priv->mutex);
@@ -113,8 +116,7 @@ yelp_man_document_init (YelpManDocument *man)
 static void
 yelp_man_document_finalize (GObject *object)
 {
-    YelpManDocumentPrivate *priv =
-        yelp_man_document_get_instance_private (YELP_MAN_DOCUMENT (object));
+    YelpManDocumentPrivate *priv = GET_PRIV (object);
 
     if (priv->xmldoc)
 	xmlFreeDoc (priv->xmldoc);
@@ -149,8 +151,7 @@ man_request_page (YelpDocument         *document,
                   gpointer              user_data,
                   GDestroyNotify        notify)
 {
-    YelpManDocumentPrivate *priv =
-        yelp_man_document_get_instance_private (YELP_MAN_DOCUMENT (document));
+    YelpManDocumentPrivate *priv = GET_PRIV (document);
     gchar *docuri, *fulluri;
     GError *error;
     gboolean handled;
@@ -221,7 +222,7 @@ transform_chunk_ready (YelpTransform    *transform,
                        gchar            *chunk_id,
                        YelpManDocument  *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
     gchar *content;
 
     g_assert (transform == priv->transform);
@@ -251,7 +252,7 @@ static void
 transform_finished (YelpTransform    *transform,
                     YelpManDocument  *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
     gchar *docuri;
     GError *error;
 
@@ -286,7 +287,7 @@ static void
 transform_error (YelpTransform    *transform,
                  YelpManDocument  *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
     GError *error;
 
     g_assert (transform == priv->transform);
@@ -307,7 +308,7 @@ static void
 transform_finalized (YelpManDocument  *man,
                      gpointer          transform)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
  
     if (priv->xmldoc)
 	xmlFreeDoc (priv->xmldoc);
@@ -321,7 +322,7 @@ transform_finalized (YelpManDocument  *man,
 static void
 man_document_process (YelpManDocument *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
     GFile *file = NULL;
     gchar *filepath = NULL;
     GError *error;
@@ -396,7 +397,7 @@ man_document_process (YelpManDocument *man)
 static void
 man_document_disconnect (YelpManDocument *man)
 {
-    YelpManDocumentPrivate *priv = yelp_man_document_get_instance_private (man);
+    YelpManDocumentPrivate *priv = GET_PRIV (man);
     if (priv->chunk_ready) {
         g_signal_handler_disconnect (priv->transform, priv->chunk_ready);
         priv->chunk_ready = 0;
diff --git a/libyelp/yelp-man-parser.c b/libyelp/yelp-man-parser.c
index 91522b7..0217987 100644
--- a/libyelp/yelp-man-parser.c
+++ b/libyelp/yelp-man-parser.c
@@ -832,6 +832,7 @@ parse_n (YelpManParser *parser, GError **error)
         xmlNewTextChild (parser->section_node, NULL,
                          BAD_CAST "title",
                          BAD_CAST parser->accumulator->str);
+
         g_string_truncate (parser->accumulator, 0);
 
         parser->section_state = SECTION_BODY;
@@ -1266,7 +1267,7 @@ unicode_strstrip (gchar *str)
     }
     start = skip_whitespace (str);
 
-    memmove (str, start, end - start);
+    g_memmove (str, start, end - start);
     *(str + (end - start)) = '\0';
 }
 
diff --git a/libyelp/yelp-search-entry.c b/libyelp/yelp-search-entry.c
index 0284a3f..2b5a819 100644
--- a/libyelp/yelp-search-entry.c
+++ b/libyelp/yelp-search-entry.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2009-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2009-2014 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -123,7 +123,8 @@ static GHashTable *completions;
 
 static guint search_entry_signals[LAST_SIGNAL] = {0,};
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpSearchEntry, yelp_search_entry, GTK_TYPE_SEARCH_ENTRY)
+G_DEFINE_TYPE (YelpSearchEntry, yelp_search_entry, GTK_TYPE_SEARCH_ENTRY)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE((object), YELP_TYPE_SEARCH_ENTRY, YelpSearchEntryPrivate))
 
 static void
 yelp_search_entry_class_init (YelpSearchEntryClass *klass)
@@ -192,6 +193,9 @@ yelp_search_entry_class_init (YelpSearchEntryClass *klass)
 							  G_PARAM_READWRITE |
                                                           G_PARAM_STATIC_STRINGS));
 
+    g_type_class_add_private ((GObjectClass *) klass,
+                              sizeof (YelpSearchEntryPrivate));
+
     completions = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
 }
 
@@ -203,8 +207,7 @@ yelp_search_entry_init (YelpSearchEntry *entry)
 static void
 search_entry_constructed (GObject *object)
 {
-    YelpSearchEntryPrivate *priv =
-        yelp_search_entry_get_instance_private (YELP_SEARCH_ENTRY (object));
+    YelpSearchEntryPrivate *priv = GET_PRIV (object);
 
     g_signal_connect (object, "activate",
                       G_CALLBACK (entry_activate_cb), object);
@@ -215,8 +218,7 @@ search_entry_constructed (GObject *object)
 static void
 search_entry_dispose (GObject *object)
 {
-    YelpSearchEntryPrivate *priv =
-        yelp_search_entry_get_instance_private (YELP_SEARCH_ENTRY (object));
+    YelpSearchEntryPrivate *priv = GET_PRIV (object);
 
     if (priv->view) {
         g_object_unref (priv->view);
@@ -234,8 +236,7 @@ search_entry_dispose (GObject *object)
 static void
 search_entry_finalize (GObject *object)
 {
-    YelpSearchEntryPrivate *priv =
-        yelp_search_entry_get_instance_private (YELP_SEARCH_ENTRY (object));
+    YelpSearchEntryPrivate *priv = GET_PRIV (object);
 
     g_free (priv->completion_uri);
 
@@ -248,8 +249,7 @@ search_entry_get_property   (GObject      *object,
                                GValue       *value,
                                GParamSpec   *pspec)
 {
-    YelpSearchEntryPrivate *priv =
-        yelp_search_entry_get_instance_private (YELP_SEARCH_ENTRY (object));
+    YelpSearchEntryPrivate *priv = GET_PRIV (object);
 
     switch (prop_id) {
     case PROP_VIEW:
@@ -270,8 +270,7 @@ search_entry_set_property   (GObject      *object,
                                const GValue *value,
                                GParamSpec   *pspec)
 {
-    YelpSearchEntryPrivate *priv =
-        yelp_search_entry_get_instance_private (YELP_SEARCH_ENTRY (object));
+    YelpSearchEntryPrivate *priv = GET_PRIV (object);
 
     switch (prop_id) {
     case PROP_VIEW:
@@ -290,7 +289,7 @@ static void
 search_entry_search_activated  (YelpSearchEntry *entry)
 {
     YelpUri *base, *uri;
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
 
     g_object_get (priv->view, "yelp-uri", &base, NULL);
     if (base == NULL)
@@ -307,7 +306,7 @@ search_entry_bookmark_clicked  (YelpSearchEntry *entry)
 {
     YelpUri *uri;
     gchar *doc_uri, *page_id;
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
 
     g_object_get (priv->view,
                   "yelp-uri", &uri,
@@ -338,7 +337,7 @@ static void
 search_entry_set_completion (YelpSearchEntry *entry,
 			     GtkTreeModel    *model)
 {
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
     GList *cells;
     GtkCellRenderer *icon_cell, *bookmark_cell;
 
@@ -402,7 +401,7 @@ cell_set_completion_bookmark_icon (GtkCellLayout     *layout,
                                    GtkTreeIter       *iter,
                                    YelpSearchEntry *entry)
 {
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
 
     if (priv->completion_uri) {
         gchar *page_id = NULL;
@@ -556,7 +555,7 @@ entry_match_selected (GtkEntryCompletion *completion,
     YelpUri *base, *uri;
     gchar *page, *xref;
     gint flags;
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
 
     gtk_tree_model_get (model, iter, COMPLETION_COL_FLAGS, &flags, -1);
     if (flags & COMPLETION_FLAG_ACTIVATE_SEARCH) {
@@ -591,7 +590,7 @@ view_loaded (YelpView          *view,
     YelpUri *uri;
     gchar *doc_uri;
     GtkTreeModel *completion;
-    YelpSearchEntryPrivate *priv = yelp_search_entry_get_instance_private (entry);
+    YelpSearchEntryPrivate *priv = GET_PRIV (entry);
     YelpDocument *document = yelp_view_get_document (view);
 
     g_object_get (view, "yelp-uri", &uri, NULL);
diff --git a/libyelp/yelp-settings.c b/libyelp/yelp-settings.c
index 576bfbe..7c3cae7 100644
--- a/libyelp/yelp-settings.c
+++ b/libyelp/yelp-settings.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2004-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2004-2009 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -29,7 +29,7 @@
 
 #include "yelp-settings.h"
 
-struct _YelpSettingsPrivate {
+struct _YelpSettingsPriv {
     GMutex        mutex;
 
     gchar         colors[YELP_SETTINGS_NUM_COLORS][8];
@@ -67,7 +67,8 @@ enum {
   PROP_EDITOR_MODE
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpSettings, yelp_settings, G_TYPE_OBJECT)
+G_DEFINE_TYPE (YelpSettings, yelp_settings, G_TYPE_OBJECT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_SETTINGS, YelpSettingsPriv))
 
 static void           yelp_settings_constructed  (GObject              *object);
 static void           yelp_settings_finalize     (GObject              *object);
@@ -162,6 +163,8 @@ yelp_settings_class_init (YelpSettingsClass *klass)
 		      0, NULL, NULL,
 		      g_cclosure_marshal_VOID__VOID,
 		      G_TYPE_NONE, 0);
+
+    g_type_class_add_private (klass, sizeof (YelpSettingsPriv));
 }
 
 static void
@@ -169,7 +172,7 @@ yelp_settings_init (YelpSettings *settings)
 {
     gint i;
 
-    settings->priv = yelp_settings_get_instance_private (settings);
+    settings->priv = GET_PRIV (settings);
     g_mutex_init (&settings->priv->mutex);
 
     for (i = 0; i < YELP_SETTINGS_NUM_FONTS; i++) {
diff --git a/libyelp/yelp-settings.h b/libyelp/yelp-settings.h
index 9324c66..25c9230 100644
--- a/libyelp/yelp-settings.h
+++ b/libyelp/yelp-settings.h
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2004-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2004-2009 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -32,13 +32,13 @@ G_BEGIN_DECLS
 #define YELP_IS_SETTINGS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), YELP_TYPE_SETTINGS))
 #define YELP_SETTINGS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), YELP_TYPE_SETTINGS, YelpSettingsClass))
 
-typedef struct _YelpSettings        YelpSettings;
-typedef struct _YelpSettingsClass   YelpSettingsClass;
-typedef struct _YelpSettingsPrivate YelpSettingsPrivate;
+typedef struct _YelpSettings      YelpSettings;
+typedef struct _YelpSettingsClass YelpSettingsClass;
+typedef struct _YelpSettingsPriv  YelpSettingsPriv;
 
 struct _YelpSettings {
-    GObject              parent;
-    YelpSettingsPrivate *priv;
+    GObject           parent;
+    YelpSettingsPriv *priv;
 };
 
 struct _YelpSettingsClass {
diff --git a/libyelp/yelp-simple-document.c b/libyelp/yelp-simple-document.c
index 735e182..e019fad 100644
--- a/libyelp/yelp-simple-document.c
+++ b/libyelp/yelp-simple-document.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2003-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2003-2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -39,7 +39,7 @@ struct _Request {
     gint                  idle_funcs;
 };
 
-struct _YelpSimpleDocumentPrivate {
+struct _YelpSimpleDocumentPriv {
     GFile        *file;
     GInputStream *stream;
     gchar        *page_id;
@@ -56,7 +56,8 @@ struct _YelpSimpleDocumentPrivate {
 
 #define BUFFER_SIZE 4096
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpSimpleDocument, yelp_simple_document, YELP_TYPE_DOCUMENT)
+G_DEFINE_TYPE (YelpSimpleDocument, yelp_simple_document, YELP_TYPE_DOCUMENT)
+#define GET_PRIV(object) (G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_SIMPLE_DOCUMENT, YelpSimpleDocumentPriv))
 
 static void           yelp_simple_document_dispose     (GObject                 *object);
 static void           yelp_simple_document_finalize    (GObject                 *object);
@@ -106,12 +107,14 @@ yelp_simple_document_class_init (YelpSimpleDocumentClass *klass)
     document_class->read_contents = document_read_contents;
     document_class->finish_read = document_finish_read;
     document_class->get_mime_type = document_get_mime_type;
+
+    g_type_class_add_private (klass, sizeof (YelpSimpleDocumentPriv));
 }
 
 static void
 yelp_simple_document_init (YelpSimpleDocument *document)
 {
-    document->priv = yelp_simple_document_get_instance_private (document);
+    document->priv = GET_PRIV (document);
 
     document->priv->file = NULL;
     document->priv->stream = NULL;
@@ -192,9 +195,12 @@ document_request_page (YelpDocument         *document,
     request->callback = callback;
     request->user_data = user_data;
 
-    request->cancellable = g_object_ref (cancellable);
-    g_signal_connect (cancellable, "cancelled",
-		      G_CALLBACK (request_cancel), request);
+    if (cancellable) {
+        request->cancellable = g_object_ref (cancellable);
+
+        g_signal_connect (cancellable, "cancelled",
+	    	      G_CALLBACK (request_cancel), request);
+    }
 
     simple->priv->reqs = g_slist_prepend (simple->priv->reqs, request);
 
@@ -376,7 +382,14 @@ stream_read_cb (GInputStream       *stream,
 	   byte.  I'm 99.99% certain I'm right.
 	 */
 	g_assert (document->priv->contents_read < document->priv->contents_len);
-	document->priv->contents[document->priv->contents_read + 1] = '\0';
+
+  //         ...
+  //        .
+  //document->priv->contents[document->priv->contents_len] = '\0';
+  document->priv->contents_len = document->priv->contents_read + 1;
+  document->priv->contents = g_realloc (document->priv->contents,
+                  document->priv->contents_len);
+  document->priv->contents[document->priv->contents_len - 1] = '\0';
 	g_input_stream_close_async (document->priv->stream,
 				    G_PRIORITY_DEFAULT,
 				    NULL,
diff --git a/libyelp/yelp-simple-document.h b/libyelp/yelp-simple-document.h
index de306f8..4ef78f6 100644
--- a/libyelp/yelp-simple-document.h
+++ b/libyelp/yelp-simple-document.h
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2003-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2003-2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -36,13 +36,13 @@ G_BEGIN_DECLS
 #define YELP_IS_SIMPLE_DOCUMENT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), YELP_TYPE_SIMPLE_DOCUMENT))
 #define YELP_SIMPLE_DOCUMENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), YELP_TYPE_SIMPLE_DOCUMENT, YelpSimpleDocumentClass))
 
-typedef struct _YelpSimpleDocument        YelpSimpleDocument;
-typedef struct _YelpSimpleDocumentClass   YelpSimpleDocumentClass;
-typedef struct _YelpSimpleDocumentPrivate YelpSimpleDocumentPrivate;
+typedef struct _YelpSimpleDocument      YelpSimpleDocument;
+typedef struct _YelpSimpleDocumentClass YelpSimpleDocumentClass;
+typedef struct _YelpSimpleDocumentPriv  YelpSimpleDocumentPriv;
 
 struct _YelpSimpleDocument {
     YelpDocument parent;
-    YelpSimpleDocumentPrivate *priv;
+    YelpSimpleDocumentPriv *priv;
 };
 
 struct _YelpSimpleDocumentClass {
diff --git a/libyelp/yelp-sqlite-storage.c b/libyelp/yelp-sqlite-storage.c
index 42853fb..c872f72 100644
--- a/libyelp/yelp-sqlite-storage.c
+++ b/libyelp/yelp-sqlite-storage.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2011-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2011 Shaun McCance <shaunm@gnome.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -66,14 +66,13 @@ enum {
 
 G_DEFINE_TYPE_WITH_CODE (YelpSqliteStorage, yelp_sqlite_storage, G_TYPE_OBJECT,
                          G_IMPLEMENT_INTERFACE (YELP_TYPE_STORAGE,
-                                                yelp_sqlite_storage_iface_init)
-                         G_ADD_PRIVATE (YelpSqliteStorage) )
+                                                yelp_sqlite_storage_iface_init))
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_SQLITE_STORAGE, YelpSqliteStoragePrivate))
 
 static void
 yelp_sqlite_storage_finalize (GObject *object)
 {
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (object));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (object);
 
     if (priv->filename)
         g_free (priv->filename);
@@ -89,7 +88,7 @@ yelp_sqlite_storage_finalize (GObject *object)
 static void
 yelp_sqlite_storage_init (YelpSqliteStorage *storage)
 {
-    YelpSqliteStoragePrivate *priv = yelp_sqlite_storage_get_instance_private (storage);
+    YelpSqliteStoragePrivate *priv = GET_PRIV (storage);
     g_mutex_init (&priv->mutex);
 }
 
@@ -98,8 +97,7 @@ yelp_sqlite_storage_constructed (GObject *object)
 {
     int status;
     sqlite3_stmt *stmt = NULL;
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (object));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (object);
 
     if (priv->filename != NULL)
         status = sqlite3_open (priv->filename, &(priv->db));
@@ -139,6 +137,8 @@ yelp_sqlite_storage_class_init (YelpSqliteStorageClass *klass)
     object_class->get_property = yelp_sqlite_storage_get_property;
     object_class->set_property = yelp_sqlite_storage_set_property;
 
+    g_type_class_add_private (klass, sizeof (YelpSqliteStoragePrivate));
+
     g_object_class_install_property (object_class,
                                      PROP_FILENAME,
                                      g_param_spec_string ("filename",
@@ -176,8 +176,7 @@ yelp_sqlite_storage_get_property (GObject    *object,
                                   GValue     *value,
                                   GParamSpec *pspec)
 {
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (object));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (object);
 
     switch (prop_id) {
     case PROP_FILENAME:
@@ -195,8 +194,7 @@ yelp_sqlite_storage_set_property (GObject      *object,
                                   const GValue *value,
                                   GParamSpec   *pspec)
 {
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (object));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (object);
 
     switch (prop_id) {
     case PROP_FILENAME:
@@ -220,8 +218,7 @@ yelp_sqlite_storage_update (YelpStorage   *storage,
                             const gchar   *text)
 {
     sqlite3_stmt *stmt = NULL;
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (storage));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (storage);
 
     g_mutex_lock (&priv->mutex);
 
@@ -259,9 +256,7 @@ yelp_sqlite_storage_search (YelpStorage   *storage,
     sqlite3_stmt *stmt = NULL;
     GVariantBuilder builder;
     GVariant *ret;
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (storage));
-
+    YelpSqliteStoragePrivate *priv = GET_PRIV (storage);
 
     g_mutex_lock (&priv->mutex);
 
@@ -295,8 +290,7 @@ yelp_sqlite_storage_get_root_title (YelpStorage *storage,
 {
     gchar *ret = NULL;
     sqlite3_stmt *stmt = NULL;
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (storage));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (storage);
 
     g_mutex_lock (&priv->mutex);
 
@@ -319,8 +313,7 @@ yelp_sqlite_storage_set_root_title (YelpStorage *storage,
                                     const gchar *title)
 {
     sqlite3_stmt *stmt = NULL;
-    YelpSqliteStoragePrivate *priv =
-        yelp_sqlite_storage_get_instance_private (YELP_SQLITE_STORAGE (storage));
+    YelpSqliteStoragePrivate *priv = GET_PRIV (storage);
 
     g_mutex_lock (&priv->mutex);
 
diff --git a/libyelp/yelp-transform.c b/libyelp/yelp-transform.c
index e74eb46..8438b4e 100644
--- a/libyelp/yelp-transform.c
+++ b/libyelp/yelp-transform.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2003-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2003-2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -85,6 +85,9 @@ enum {
 };
 static gint signals[LAST_SIGNAL] = { 0 };
 
+G_DEFINE_TYPE (YelpTransform, yelp_transform, G_TYPE_OBJECT)
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_TRANSFORM, YelpTransformPrivate))
+
 typedef struct _YelpTransformPrivate YelpTransformPrivate;
 struct _YelpTransformPrivate {
     xmlDocPtr                input;
@@ -109,14 +112,12 @@ struct _YelpTransformPrivate {
     GError                 *error;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpTransform, yelp_transform, G_TYPE_OBJECT)
-
 /******************************************************************************/
 
 static void
 yelp_transform_init (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
     priv->queue = g_async_queue_new_full (g_free);
     priv->chunks = g_hash_table_new_full (g_str_hash,
                                           g_str_equal,
@@ -155,6 +156,8 @@ yelp_transform_class_init (YelpTransformClass *klass)
                                    g_cclosure_marshal_VOID__VOID,
                                    G_TYPE_NONE, 0);
 
+    g_type_class_add_private (klass, sizeof (YelpTransformPrivate));
+
     g_object_class_install_property (object_class,
                                      PROP_STYLESHEET,
                                      g_param_spec_string ("stylesheet",
@@ -169,8 +172,7 @@ yelp_transform_class_init (YelpTransformClass *klass)
 static void
 yelp_transform_dispose (GObject *object)
 {
-    YelpTransformPrivate *priv =
-        yelp_transform_get_instance_private (YELP_TRANSFORM (object));
+    YelpTransformPrivate *priv = GET_PRIV (object);
 
     debug_print (DB_FUNCTION, "entering\n");
 
@@ -204,7 +206,6 @@ yelp_transform_dispose (GObject *object)
         xmlFreeDoc (priv->output);
         priv->output = NULL;
     }
-    g_clear_pointer (&priv->stylesheet_file, g_free);
 
     G_OBJECT_CLASS (yelp_transform_parent_class)->dispose (object);
 }
@@ -212,8 +213,7 @@ yelp_transform_dispose (GObject *object)
 static void
 yelp_transform_finalize (GObject *object)
 {
-    YelpTransformPrivate *priv =
-        yelp_transform_get_instance_private (YELP_TRANSFORM (object));
+    YelpTransformPrivate *priv = GET_PRIV (object);
     GHashTableIter iter;
     gpointer chunk;
 
@@ -239,8 +239,7 @@ yelp_transform_get_property (GObject    *object,
                              GValue     *value,
                              GParamSpec *pspec)
 {
-    YelpTransformPrivate *priv =
-        yelp_transform_get_instance_private (YELP_TRANSFORM (object));
+    YelpTransformPrivate *priv = GET_PRIV (object);
 
     switch (prop_id)
         {
@@ -259,8 +258,7 @@ yelp_transform_set_property (GObject      *object,
                              const GValue *value,
                              GParamSpec   *pspec)
 {
-    YelpTransformPrivate *priv =
-        yelp_transform_get_instance_private (YELP_TRANSFORM (object));
+    YelpTransformPrivate *priv = GET_PRIV (object);
 
     switch (prop_id)
         {
@@ -297,7 +295,7 @@ yelp_transform_start (YelpTransform       *transform,
                       xmlDocPtr            auxiliary,
                       const gchar * const *params)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
 
     priv->input = document;
     priv->aux = auxiliary;
@@ -319,7 +317,7 @@ gchar *
 yelp_transform_take_chunk (YelpTransform *transform,
                            const gchar   *chunk_id)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
     gchar *buf;
 
     g_mutex_lock (&priv->mutex);
@@ -337,7 +335,7 @@ yelp_transform_take_chunk (YelpTransform *transform,
 void
 yelp_transform_cancel (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
     g_mutex_lock (&priv->mutex);
     if (priv->running) {
         priv->cancelled = TRUE;
@@ -350,7 +348,7 @@ yelp_transform_cancel (YelpTransform *transform)
 GError *
 yelp_transform_get_error (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
     GError *ret = NULL;
 
     g_mutex_lock (&priv->mutex);
@@ -366,7 +364,7 @@ yelp_transform_get_error (YelpTransform *transform)
 static void
 transform_run (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
 
     debug_print (DB_FUNCTION, "entering\n");
 
@@ -433,7 +431,7 @@ transform_run (YelpTransform *transform)
 static gboolean
 transform_chunk (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
     gchar *chunk_id;
 
     debug_print (DB_FUNCTION, "entering\n");
@@ -455,7 +453,7 @@ transform_chunk (YelpTransform *transform)
 static gboolean
 transform_error (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
 
     debug_print (DB_FUNCTION, "entering\n");
 
@@ -472,7 +470,7 @@ transform_error (YelpTransform *transform)
 static gboolean
 transform_final (YelpTransform *transform)
 {
-    YelpTransformPrivate *priv = yelp_transform_get_instance_private (transform);
+    YelpTransformPrivate *priv = GET_PRIV (transform);
 
     debug_print (DB_FUNCTION, "entering\n");
 
@@ -515,7 +513,7 @@ xslt_yelp_document (xsltTransformContextPtr ctxt,
         return;
 
     transform = YELP_TRANSFORM (ctxt->_private);
-    priv = yelp_transform_get_instance_private (transform);
+    priv = GET_PRIV (transform);
 
     page_id = xsltEvalAttrValueTemplate (ctxt, inst,
                                          (const xmlChar *) "href",
@@ -599,7 +597,7 @@ xslt_yelp_aux (xmlXPathParserContextPtr ctxt, int nargs)
 
     tctxt = xsltXPathGetTransformContext (ctxt);
     transform = YELP_TRANSFORM (tctxt->_private);
-    priv = yelp_transform_get_instance_private (transform);
+    priv = GET_PRIV (transform);
 
     priv->aux_xslt = xsltNewDocument (tctxt, priv->aux);
 
diff --git a/libyelp/yelp-uri-builder.c b/libyelp/yelp-uri-builder.c
index 680bf90..32dd24c 100644
--- a/libyelp/yelp-uri-builder.c
+++ b/libyelp/yelp-uri-builder.c
@@ -140,4 +140,4 @@ gchar *
 build_network_scheme (const gchar *scheme)
 {
 	return g_strdup_printf (BOGUS_PREFIX "%s", scheme);
-}
+}
\ No newline at end of file
diff --git a/libyelp/yelp-uri.c b/libyelp/yelp-uri.c
index ffc49cc..05a8666 100644
--- a/libyelp/yelp-uri.c
+++ b/libyelp/yelp-uri.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2009-2020 Shaun McCance  <shaunm@gnome.org>
+ * Copyright (C) 2009 Shaun McCance  <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -61,6 +61,9 @@ static void           resolve_gfile              (YelpUri        *uri,
 static gboolean       is_man_path                (const gchar    *uri,
                                                   const gchar    *encoding);
 
+G_DEFINE_TYPE (YelpUri, yelp_uri, G_TYPE_OBJECT)
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_URI, YelpUriPrivate))
+
 typedef struct _YelpUriPrivate YelpUriPrivate;
 struct _YelpUriPrivate {
     GThread              *resolver;
@@ -89,8 +92,6 @@ enum {
 };
 static guint uri_signals[LAST_SIGNAL] = {0,};
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpUri, yelp_uri, G_TYPE_OBJECT)
-
 /******************************************************************************/
 
 static const gchar *mancats[] = {
@@ -134,12 +135,14 @@ yelp_uri_class_init (YelpUriClass *klass)
                       0, NULL, NULL,
                       g_cclosure_marshal_VOID__VOID,
                       G_TYPE_NONE, 0);
+
+    g_type_class_add_private (klass, sizeof (YelpUriPrivate));
 }
 
 static void
 yelp_uri_init (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     priv->query = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
 
@@ -149,7 +152,7 @@ yelp_uri_init (YelpUri *uri)
 static void
 yelp_uri_dispose (GObject *object)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (YELP_URI (object));
+    YelpUriPrivate *priv = GET_PRIV (object);
 
     if (priv->gfile) {
         g_object_unref (priv->gfile);
@@ -172,7 +175,7 @@ yelp_uri_dispose (GObject *object)
 static void
 yelp_uri_finalize (GObject *object)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (YELP_URI (object));
+    YelpUriPrivate *priv = GET_PRIV (object);
 
     g_free (priv->docuri);
     g_free (priv->fulluri);
@@ -200,10 +203,11 @@ yelp_uri_new_relative (YelpUri *base, const gchar *arg)
 
     uri = (YelpUri *) g_object_new (YELP_TYPE_URI, NULL);
 
-    priv = yelp_uri_get_instance_private (uri);
+    priv = GET_PRIV (uri);
     priv->doctype = YELP_URI_DOCUMENT_TYPE_UNRESOLVED;
-    if (base)
+    if (base){
         priv->res_base = g_object_ref (base);
+        }
     priv->res_arg = g_strdup (arg);
 
     return uri;
@@ -219,7 +223,7 @@ yelp_uri_new_search (YelpUri      *base,
 
     uri = (YelpUri *) g_object_new (YELP_TYPE_URI, NULL);
 
-    priv = yelp_uri_get_instance_private (uri);
+    priv = GET_PRIV (uri);
     priv->doctype = YELP_URI_DOCUMENT_TYPE_UNRESOLVED;
     if (base)
         priv->res_base = g_object_ref (base);
@@ -235,7 +239,7 @@ yelp_uri_new_search (YelpUri      *base,
 void
 yelp_uri_resolve (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     if (priv->res_base && !yelp_uri_is_resolved (priv->res_base)) {
         g_signal_connect_swapped (priv->res_base, "resolved",
@@ -251,7 +255,7 @@ yelp_uri_resolve (YelpUri *uri)
 void
 yelp_uri_resolve_sync (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     if (priv->doctype != YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return;
@@ -290,7 +294,7 @@ yelp_uri_resolve_sync (YelpUri *uri)
 static void
 resolve_start (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     if (priv->resolver == NULL) {
         g_object_ref (uri);
@@ -303,14 +307,22 @@ resolve_start (YelpUri *uri)
 static void
 resolve_sync (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     if (g_str_has_prefix (priv->res_arg, "ghelp:")
         || g_str_has_prefix (priv->res_arg, "gnome-help:")) {
         resolve_ghelp_uri (uri);
     }
     else if (g_str_has_prefix (priv->res_arg, "help:")) {
-        resolve_help_uri (uri);
+    //jeong
+        //if (priv->res_base) {
+        //    YelpUriPrivate *base_priv = GET_PRIV (priv->res_base);
+        //    if (base_priv->doctype == YELP_URI_DOCUMENT_TYPE_HTML ||
+        //        base_priv->doctype == YELP_URI_DOCUMENT_TYPE_EXTERNAL)
+        //        resolve_file_path (uri);
+        //}
+        //else
+            resolve_help_uri (uri);
     }
     else if (g_str_has_prefix (priv->res_arg, "help-list:")) {
         resolve_help_list_uri (uri);
@@ -330,7 +342,7 @@ resolve_sync (YelpUri *uri)
             priv->tmptype = YELP_URI_DOCUMENT_TYPE_ERROR;
             return;
         }
-        base_priv = yelp_uri_get_instance_private (priv->res_base);
+        base_priv = GET_PRIV (priv->res_base);
         switch (base_priv->doctype) {
         case YELP_URI_DOCUMENT_TYPE_UNRESOLVED:
             break;
@@ -388,7 +400,7 @@ resolve_async (YelpUri *uri)
 static gboolean
 resolve_final (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     priv->resolver = NULL;
 
@@ -417,21 +429,21 @@ resolve_final (YelpUri *uri)
 gboolean
 yelp_uri_is_resolved (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     return priv->doctype != YELP_URI_DOCUMENT_TYPE_UNRESOLVED;
 }
 
 YelpUriDocumentType
 yelp_uri_get_document_type (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     return priv->doctype;
 }
 
 gchar *
 yelp_uri_get_document_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
 
@@ -449,7 +461,7 @@ yelp_uri_get_document_uri (YelpUri *uri)
 gchar *
 yelp_uri_get_canonical_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
     return g_strdup (priv->fulluri);
@@ -458,7 +470,7 @@ yelp_uri_get_canonical_uri (YelpUri *uri)
 GFile *
 yelp_uri_get_file (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
     return priv->gfile ? g_object_ref (priv->gfile) : NULL;
@@ -467,7 +479,7 @@ yelp_uri_get_file (YelpUri *uri)
 gchar **
 yelp_uri_get_search_path (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
     return g_strdupv (priv->search_path);
@@ -476,7 +488,7 @@ yelp_uri_get_search_path (YelpUri *uri)
 gchar *
 yelp_uri_get_page_id (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
     return g_strdup (priv->page_id);
@@ -485,7 +497,7 @@ yelp_uri_get_page_id (YelpUri *uri)
 gchar *
 yelp_uri_get_frag_id (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     if (priv->doctype == YELP_URI_DOCUMENT_TYPE_UNRESOLVED)
         return NULL;
     return g_strdup (priv->frag_id);
@@ -495,7 +507,7 @@ gchar *
 yelp_uri_get_query (YelpUri      *uri,
                     const gchar  *key)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     const gchar *ret = g_hash_table_lookup (priv->query, key);
     if (ret)
         return g_strdup (ret);
@@ -509,7 +521,7 @@ gchar *
 yelp_uri_locate_file_uri (YelpUri     *uri,
                           const gchar *filename)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     GFile *gfile;
     gchar *fullpath;
     gchar *returi = NULL;
@@ -543,7 +555,7 @@ yelp_uri_locate_file_uri (YelpUri     *uri,
 static void
 resolve_file_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     gchar *uristr;
     const gchar *hash = strchr (priv->res_arg, '#');
 
@@ -563,7 +575,7 @@ static void
 resolve_file_path (YelpUri *uri)
 {
     YelpUriPrivate *base_priv = NULL;
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     gchar *path;
     const gchar *hash;
 
@@ -575,7 +587,7 @@ resolve_file_path (YelpUri *uri)
     }
 
     if (priv->res_base)
-        base_priv = yelp_uri_get_instance_private (priv->res_base);
+        base_priv = GET_PRIV (priv->res_base);
 
     hash = strchr (priv->res_arg, '#');
     if (hash) {
@@ -629,7 +641,7 @@ resolve_data_dirs (YelpUri      *ret,
     const gchar * const *langs = g_get_language_names ();
     /* The strings are still owned by GLib; we just own the array. */
     gchar **datadirs;
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (ret);
+    YelpUriPrivate *priv = GET_PRIV (ret);
     gchar *filename = NULL;
     gchar **searchpath = NULL;
     gint searchi, searchmax;
@@ -692,6 +704,27 @@ resolve_data_dirs (YelpUri      *ret,
                 }
                 g_free (filename);
             }
+//jeong
+            //if (langfirst) {
+            //    filename = g_strdup_printf ("%s/index.html", helpdir);
+            //    if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+            //        priv->tmptype = YELP_URI_DOCUMENT_TYPE_HTML;
+            //        continue;
+            //    }
+            //    g_free (filename);
+            //}
+            //else {
+            //    filename = g_strdup_printf ("%s/%s.html", helpdir, pageid);
+            //    if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
+            //        priv->tmptype = YELP_URI_DOCUMENT_TYPE_EXTERNAL;
+            //        continue;
+            //    }
+            //    //else {
+            //    //    priv->tmptype = YELP_URI_DOCUMENT_TYPE_EXTERNAL;
+            //    //    continue;
+            //    //}
+            //    g_free (filename);
+            //}
 
             filename = g_strdup_printf ("%s/%s.html", helpdir, pageid);
             if (g_file_test (filename, G_FILE_TEST_IS_REGULAR)) {
@@ -717,14 +750,13 @@ resolve_data_dirs (YelpUri      *ret,
     else {
         priv->gfile = g_file_new_for_path (filename);
         priv->search_path = searchpath;
-        g_free (filename);
     }
 }
 
 static void
 build_ghelp_fulluri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     g_assert (priv->tmptype != YELP_URI_DOCUMENT_TYPE_UNRESOLVED);
     g_assert (priv->docuri != NULL);
@@ -743,7 +775,7 @@ resolve_ghelp_uri (YelpUri *uri)
     /* ghelp:/path/to/file
      * ghelp:document[/file][?page][#frag]
      */
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     gchar *document, *slash, *query, *hash;
     gchar *colon, *c; /* do not free */
 
@@ -846,8 +878,8 @@ resolve_help_uri (YelpUri *uri)
 {
     /* help:document[/page][?query][#frag]
      */
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
-    gchar *document, *slash, *query, *hash;
+    YelpUriPrivate *priv = GET_PRIV (uri);
+    gchar *document, *slash, *query, *hash, *dot;
     gchar *colon, *c; /* do not free */
 
     colon = strchr (priv->res_arg, ':');
@@ -856,7 +888,7 @@ resolve_help_uri (YelpUri *uri)
         return;
     }
 
-    slash = query = hash = NULL;
+    dot = slash = query = hash = NULL;
     for (c = colon; *c != '\0'; c++) {
         if (*c == '#' && hash == NULL)
             hash = c;
@@ -864,6 +896,8 @@ resolve_help_uri (YelpUri *uri)
             query = c;
         else if (*c == '/' && slash == NULL && query == NULL && hash == NULL)
             slash = c;
+        else if (*c == '.')
+            dot = c;
     }
 
     if (slash || query || hash)
@@ -877,6 +911,9 @@ resolve_help_uri (YelpUri *uri)
                            (query ? query : hash) - slash - 1);
     else if (slash)
         slash = g_strdup (slash + 1);
+//jeong
+    if (slash && dot)
+        slash = g_strndup (slash, strlen (slash) - strlen (dot));
 
     if (query && hash)
         query = g_strndup (query + 1,
@@ -934,7 +971,7 @@ resolve_help_uri (YelpUri *uri)
 static void
 resolve_help_list_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     priv->docuri = g_strdup ("help-list:");
     priv->fulluri = g_strdup (priv->res_arg);
     priv->page_id = g_strdup ("index");
@@ -996,7 +1033,7 @@ find_man_path (gchar* name, gchar* section)
 static void
 build_man_uris (YelpUri *uri, const char *name, const char *section)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     g_assert (priv->tmptype == YELP_URI_DOCUMENT_TYPE_MAN);
     priv->docuri = g_strdup ("man:");
@@ -1013,7 +1050,7 @@ build_man_uris (YelpUri *uri, const char *name, const char *section)
 static void
 resolve_man_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     /* man:/path/to/file
      * man:name(section)
      * man:name.section
@@ -1101,7 +1138,7 @@ resolve_man_uri (YelpUri *uri)
 static void
 build_info_uris (YelpUri *uri, const char *name, const char *section)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
 
     g_assert (priv->tmptype == YELP_URI_DOCUMENT_TYPE_INFO);
     priv->docuri = g_strconcat ("info:", name, NULL);
@@ -1116,7 +1153,7 @@ build_info_uris (YelpUri *uri, const char *name, const char *section)
 static void
 resolve_info_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     /* info:/path/to/file
      * info:name#node
      * info:name
@@ -1249,9 +1286,9 @@ resolve_info_uri (YelpUri *uri)
 static void
 resolve_xref_uri (YelpUri *uri)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     const gchar *arg = priv->res_arg + 5;
-    YelpUriPrivate *base_priv = yelp_uri_get_instance_private (priv->res_base);
+    YelpUriPrivate *base_priv = GET_PRIV (priv->res_base);
 
     priv->tmptype = base_priv->doctype;
     priv->gfile = g_object_ref (base_priv->gfile);
@@ -1321,7 +1358,7 @@ resolve_xref_uri (YelpUri *uri)
 static void
 resolve_page_and_frag (YelpUri *uri, const gchar *arg)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     gchar *hash;
 
     if (!arg || arg[0] == '\0')
@@ -1341,7 +1378,7 @@ resolve_page_and_frag (YelpUri *uri, const gchar *arg)
 static void
 resolve_gfile (YelpUri *uri, const gchar *query, const gchar *hash)
 {
-    YelpUriPrivate *priv = yelp_uri_get_instance_private (uri);
+    YelpUriPrivate *priv = GET_PRIV (uri);
     GFileInfo *info;
     GError *error = NULL;
 
diff --git a/libyelp/yelp-view.c b/libyelp/yelp-view.c
index f5de164..3e5fbd0 100644
--- a/libyelp/yelp-view.c
+++ b/libyelp/yelp-view.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2009-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2009 Shaun McCance <shaunm@gnome.org>
  * Copyright (C) 2014 Igalia S.L.
  *
  * This program is free software; you can redistribute it and/or
@@ -141,17 +141,16 @@ enum {
 };
 static gint signals[LAST_SIGNAL] = { 0 };
 
+G_DEFINE_TYPE (YelpView, yelp_view, WEBKIT_TYPE_WEB_VIEW)
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_VIEW, YelpViewPrivate))
+
 static WebKitSettings *
 yelp_view_get_global_settings (void)
 {
     static WebKitSettings *websettings = NULL;
 
     if (!websettings)
-        websettings = webkit_settings_new_with_settings ("default-charset", "utf-8",
-#if WEBKIT_CHECK_VERSION(2, 23, 4)
-                                                         "enable-back-forward-navigation-gestures", TRUE,
-#endif
-                                                         NULL);
+        websettings = webkit_settings_new_with_settings ("default-charset", "utf-8", NULL);
 
     return websettings;
 }
@@ -242,8 +241,6 @@ enum {
     TARGET_URI_LIST
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (YelpView, yelp_view, WEBKIT_TYPE_WEB_VIEW)
-
 static void
 yelp_view_init (YelpView *view)
 {
@@ -255,12 +252,14 @@ yelp_view_init (YelpView *view)
       },
       {
         "CopyLink", NULL,
-        N_("_Copy Link Location"), NULL, NULL,
+        //N_("_Open Link"), NULL, NULL,
+        NULL, NULL, NULL,
         G_CALLBACK (popup_copy_link)
       },
       {
         "OpenLink", NULL,
-        N_("_Open Link"), NULL, NULL,
+        //N_("Open Link in New _Window"), NULL, NULL,
+        NULL, NULL, NULL,
         G_CALLBACK (popup_open_link)
       },
       {
@@ -295,12 +294,13 @@ yelp_view_init (YelpView *view)
       },
       {
         "CopyText", NULL,
-        N_("_Copy Text"), NULL, NULL,
+        //N_("_Copy Text"), NULL, NULL,
+        NULL, NULL, NULL,
         G_CALLBACK (popup_copy_clipboard)
       }
     };
 
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     priv->cancellable = NULL;
 
@@ -361,7 +361,7 @@ static void
 yelp_view_constructed (GObject *object)
 {
     YelpView *view = YELP_VIEW (object);
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpSettings *settings = yelp_settings_get_default ();
 
     G_OBJECT_CLASS (yelp_view_parent_class)->constructed (object);
@@ -381,7 +381,7 @@ yelp_view_constructed (GObject *object)
 static void
 yelp_view_dispose (GObject *object)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (YELP_VIEW (object));
+    YelpViewPrivate *priv = GET_PRIV (object);
 
     view_clear_load (YELP_VIEW (object));
 
@@ -432,7 +432,7 @@ yelp_view_dispose (GObject *object)
 static void
 yelp_view_finalize (GObject *object)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (YELP_VIEW (object));
+    YelpViewPrivate *priv = GET_PRIV (object);
 
     g_free (priv->popup_link_uri);
     g_free (priv->popup_link_text);
@@ -521,6 +521,8 @@ yelp_view_class_init (YelpViewClass *klass)
                       g_cclosure_marshal_VOID__VOID,
                       G_TYPE_NONE, 0);
 
+    g_type_class_add_private (klass, sizeof (YelpViewPrivate));
+
     g_object_class_install_property (object_class,
                                      PROP_URI,
                                      g_param_spec_object ("yelp-uri",
@@ -594,7 +596,7 @@ yelp_view_get_property (GObject    *object,
                         GValue     *value,
                         GParamSpec *pspec)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (YELP_VIEW (object));
+    YelpViewPrivate *priv = GET_PRIV (object);
 
     switch (prop_id)
         {
@@ -635,7 +637,7 @@ yelp_view_set_property (GObject      *object,
                         GParamSpec   *pspec)
 {
     YelpUri *uri;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (YELP_VIEW (object));
+    YelpViewPrivate *priv = GET_PRIV (object);
 
     switch (prop_id)
         {
@@ -676,7 +678,7 @@ void
 yelp_view_load_uri (YelpView *view,
                     YelpUri  *uri)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     g_object_set (view, "state", YELP_VIEW_STATE_LOADING, NULL);
 
@@ -693,7 +695,7 @@ yelp_view_load_document (YelpView     *view,
                          YelpDocument *document)
 {
     GParamSpec *spec;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     g_return_if_fail (yelp_uri_is_resolved (uri));
 
@@ -716,7 +718,7 @@ yelp_view_load_document (YelpView     *view,
 YelpDocument *
 yelp_view_get_document (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     return priv->document;
 }
 
@@ -724,7 +726,7 @@ void
 yelp_view_register_actions (YelpView   *view,
                             GActionMap *map)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     g_action_map_add_action (map, G_ACTION (priv->print_action));
     g_action_map_add_action (map, G_ACTION (priv->back_action));
     g_action_map_add_action (map, G_ACTION (priv->forward_action));
@@ -738,7 +740,7 @@ static void
 yelp_view_resolve_uri (YelpView *view,
                        YelpUri  *uri)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     if (yelp_uri_is_resolved (uri)) {
         uri_resolved (uri, view);
@@ -791,7 +793,6 @@ document_callback (YelpDocument       *document,
     }
 
     mime_type = yelp_document_get_mime_type (document, data->page_id);
-
     contents = yelp_document_read_contents (document, data->page_id);
 
     if (contents) {
@@ -830,6 +831,7 @@ help_cb_uri_resolved (YelpUri                *uri,
                                     (YelpDocumentCallback) document_callback,
                                     data,
                                     (GDestroyNotify) request_async_data_free);
+
         g_object_unref (document);
 
     } else {
@@ -916,7 +918,7 @@ yelp_view_add_link_action (YelpView                *view,
                            gpointer                 data)
 {
     YelpActionEntry *entry;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     entry = g_new0 (YelpActionEntry, 1);
     entry->action = g_object_ref (action);
@@ -929,7 +931,7 @@ yelp_view_add_link_action (YelpView                *view,
 YelpUri *
 yelp_view_get_active_link_uri (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpUri *uri;
 
     uri = yelp_uri_new_relative (priv->uri, priv->popup_link_uri);
@@ -940,7 +942,7 @@ yelp_view_get_active_link_uri (YelpView *view)
 gchar *
 yelp_view_get_active_link_text (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     return g_strdup (priv->popup_link_text);
 }
 
@@ -1028,7 +1030,7 @@ view_install_installed (GDBusConnection *connection,
     }
     else if (info->uri) {
         gchar *struri, *docuri;
-        YelpViewPrivate *priv = yelp_view_get_instance_private (info->view);
+        YelpViewPrivate *priv = GET_PRIV (info->view);
         docuri = yelp_uri_get_document_uri (priv->uri);
         if (g_str_equal (docuri, info->uri)) {
             struri = yelp_uri_get_canonical_uri (priv->uri);
@@ -1051,7 +1053,7 @@ view_install_uri (YelpView    *view,
     GVariantBuilder *strv;
     YelpInstallInfo *info;
     guint32 xid = 0;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     GtkWidget *gtkwin;
     GdkWindow *gdkwin;
     /* do not free */
@@ -1165,7 +1167,7 @@ static void
 popup_open_link (GtkAction   *action,
                  YelpView    *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpUri *uri;
 
     uri = yelp_uri_new_relative (priv->uri, priv->popup_link_uri);
@@ -1184,7 +1186,7 @@ static void
 popup_open_link_new (GtkAction   *action,
                      YelpView    *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpUri *uri;
 
     uri = yelp_uri_new_relative (priv->uri, priv->popup_link_uri);
@@ -1203,7 +1205,7 @@ static void
 popup_copy_link (GtkAction   *action,
                  YelpView    *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     gtk_clipboard_set_text (gtk_widget_get_clipboard (GTK_WIDGET (view), GDK_SELECTION_CLIPBOARD),
                             priv->popup_link_uri,
                             -1);
@@ -1246,7 +1248,7 @@ popup_save_image (GtkAction   *action,
     GtkWidget *dialog, *window;
     gchar *basename;
     gint res;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     for (window = gtk_widget_get_parent (GTK_WIDGET (view));
          window && !GTK_IS_WINDOW (window);
@@ -1301,7 +1303,7 @@ popup_send_image (GtkAction   *action,
     GAppInfo *app;
     GAppLaunchContext *context;
     GError *error = NULL;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     command = g_strdup_printf ("%s %s", nautilus_sendto, priv->popup_image_uri);
     context = (GAppLaunchContext *) gdk_display_get_app_launch_context (gtk_widget_get_display (GTK_WIDGET (view)));
@@ -1327,7 +1329,7 @@ static void
 popup_copy_code (GtkAction   *action,
                  YelpView    *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     GtkClipboard *clipboard;
 
     if (!priv->popup_code_text)
@@ -1341,7 +1343,7 @@ static void
 popup_save_code (GtkAction   *action,
                  YelpView    *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     GtkWidget *dialog, *window;
     gint res;
 
@@ -1426,7 +1428,7 @@ view_populate_context_menu (YelpView            *view,
                             WebKitHitTestResult *hit_test_result,
                             gpointer             user_data)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     WebKitContextMenuItem *item;
     GtkAction *action;
     GVariant *dom_info_variant;
@@ -1474,6 +1476,7 @@ view_populate_context_menu (YelpView            *view,
 
             action = gtk_action_group_get_action (priv->popup_actions,
               "OpenLink");
+            gtk_action_set_label (action, _("_Open Link"));
             item = webkit_context_menu_item_new (action);
             webkit_context_menu_append (context_menu, item);
 
@@ -1487,6 +1490,7 @@ view_populate_context_menu (YelpView            *view,
             else {
                 action = gtk_action_group_get_action (priv->popup_actions,
                   "OpenLinkNew");
+                gtk_action_set_label (action, _("Open Link in New _Window"));
                 item = webkit_context_menu_item_new (action);
                 webkit_context_menu_append (context_menu, item);
             }
@@ -1581,6 +1585,7 @@ view_populate_context_menu (YelpView            *view,
 
         action = gtk_action_group_get_action (priv->popup_actions,
                                               "CopyText");
+        gtk_action_set_label (action, _("_Copy Text"));
         item = webkit_context_menu_item_new (action);
         webkit_context_menu_append (context_menu, item);
     }
@@ -1633,7 +1638,7 @@ view_policy_decision_requested (YelpView                *view,
                                 WebKitPolicyDecisionType type,
                                 gpointer                 user_data)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     WebKitNavigationAction *action;
     WebKitURIRequest *request;
     gchar *fixed_uri;
@@ -1661,7 +1666,6 @@ view_policy_decision_requested (YelpView                *view,
     }
 
     webkit_policy_decision_ignore (decision);
-
     uri = yelp_uri_new_relative (priv->uri, fixed_uri);
     yelp_view_load_uri ((YelpView *) view, uri);
     g_object_unref (uri);
@@ -1675,7 +1679,7 @@ view_load_status_changed (WebKitWebView   *view,
                           WebKitLoadEvent  load_event,
                           gpointer         user_data)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (YELP_VIEW (view));
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     if (priv->state == YELP_VIEW_STATE_ERROR)
         return;
@@ -1736,9 +1740,9 @@ view_load_status_changed (WebKitWebView   *view,
         if (priv->page_title == NULL) {
             GParamSpec *spec;
             priv->page_title = g_strdup (webkit_web_view_get_title (view));
-            spec = g_object_class_find_property ((GObjectClass *) YELP_VIEW_GET_CLASS (view),
-                                                 "page-title");
-            g_signal_emit_by_name (view, "notify::page-title", spec);
+            if (priv->page_title != NULL &&  0 < strlen (priv->page_title)) {
+                g_signal_emit_by_name (view, "notify::root-title", NULL);
+            }
         }
 
         g_signal_emit (view, signals[LOADED], 0);
@@ -1767,7 +1771,7 @@ view_print_action (GAction *action, GVariant *parameter, YelpView *view)
     GtkWidget *window;
     WebKitPrintOperation *print_operation;
     GtkPrintSettings *settings;
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     window = gtk_widget_get_toplevel (GTK_WIDGET (view));
 
@@ -1798,7 +1802,7 @@ view_history_action (GAction   *action,
 static void
 view_history_changed (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     WebKitWebView *web_view = WEBKIT_WEB_VIEW (view);
 
     g_simple_action_set_enabled (priv->back_action, webkit_web_view_can_go_back (web_view));
@@ -1810,7 +1814,7 @@ view_navigation_action (GAction  *action,
                         GVariant *parameter,
                         YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     gchar *page_id, *new_id, *xref;
     YelpUri *new_uri;
 
@@ -1839,7 +1843,7 @@ view_navigation_action (GAction  *action,
 static void
 view_clear_load (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
 
     if (priv->resolve_uri != NULL) {
         if (priv->uri_resolved != 0) {
@@ -1910,7 +1914,7 @@ fix_docbook_uri (YelpUri *docbook_uri, YelpDocument* document)
 static void
 view_load_page (YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     gchar *uri_str, *tmp_uri;
 
     g_return_if_fail (priv->cancellable == NULL);
@@ -1969,7 +1973,7 @@ static void
 view_show_error_page (YelpView *view,
                       GError   *error)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpSettings *settings = yelp_settings_get_default ();
     GtkIconTheme *icontheme;
     GtkIconInfo *icon;
@@ -2121,7 +2125,7 @@ static void
 uri_resolved (YelpUri  *uri,
               YelpView *view)
 {
-    YelpViewPrivate *priv = yelp_view_get_instance_private (view);
+    YelpViewPrivate *priv = GET_PRIV (view);
     YelpUriDocumentType doctype;
     YelpDocument *document;
     GError *error = NULL;
@@ -2215,8 +2219,9 @@ uri_resolved (YelpUri  *uri,
             g_object_unref (priv->document);
         priv->document = document;
 
-        if (priv->load_page_after_resolved)
+        if (priv->load_page_after_resolved) {
             view_load_page (view);
+        }
     } else {
         if (priv->document != NULL) {
             g_object_unref (priv->document);
diff --git a/src/yelp-application.c b/src/yelp-application.c
index 4e4d7a3..1524a18 100644
--- a/src/yelp-application.c
+++ b/src/yelp-application.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2010-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2010 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -27,6 +27,7 @@
 #include <gio/gio.h>
 #include <gio/gsettingsbackend.h>
 #include <glib/gi18n.h>
+#include <glib/gstdio.h>
 #include <gtk/gtk.h>
 #ifdef GDK_WINDOWING_X11
 #include <gdk/gdkx.h>
@@ -41,7 +42,7 @@
 #include "yelp-application.h"
 #include "yelp-window.h"
 
-#define DEFAULT_URI "help:gnome-help"
+#define DEFAULT_URI "help:index"
 
 static gboolean editor_mode = FALSE;
 
@@ -51,8 +52,6 @@ option_version_cb (const gchar *option_name,
 	           gpointer     data,
 	           GError     **error)
 {
-	g_print ("%s %s\n", PACKAGE, VERSION);
-
 	exit (0);
 }
 
@@ -92,6 +91,8 @@ static void          application_adjust_font           (GAction               *a
                                                         YelpApplication       *app);
 static void          application_set_font_sensitivity  (YelpApplication       *app);
 
+//static void          yelp_application_ui_init          (YelpApplication       *app);
+
 static void          bookmarks_changed                 (GSettings             *settings,
                                                         const gchar           *key,
                                                         YelpApplication       *app);
@@ -100,31 +101,70 @@ static gboolean      window_resized                    (YelpWindow            *w
 
 typedef struct _YelpApplicationPrivate YelpApplicationPrivate;
 struct _YelpApplicationPrivate {
-    GSList *windows;
-    GHashTable *windows_by_document;
+    GSList             *windows;
+    GHashTable         *windows_by_document;
+
+    GPropertyAction    *show_cursor_action;
+    GSimpleAction      *larger_text_action;
+    GSimpleAction      *smaller_text_action;
 
-    GPropertyAction  *show_cursor_action;
-    GSimpleAction    *larger_text_action;
-    GSimpleAction    *smaller_text_action;
+    GSettingsBackend   *backend;
+    GSettings          *gsettings;
+    GHashTable         *docsettings;
 
-    GSettingsBackend *backend;
-    GSettings *gsettings;
-    GHashTable *docsettings;
+    GtkCssProvider     *provider;
+
+    GHashTable *cmd_hash;
 };
 
 G_DEFINE_TYPE_WITH_CODE (YelpApplication, yelp_application, GTK_TYPE_APPLICATION,
+                         G_ADD_PRIVATE (YelpApplication)
                          G_IMPLEMENT_INTERFACE (YELP_TYPE_BOOKMARKS,
-                                                yelp_application_iface_init)
-                         G_ADD_PRIVATE (YelpApplication) )
+                                                yelp_application_iface_init))
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_APPLICATION, YelpApplicationPrivate))
+
+static void
+yelp_application_gooroom_init (YelpApplication *app)
+{
+    FILE *fp;
+    gchar line[1024], *lineptr;
+    gchar **cmds = NULL;
+
+    YelpApplicationPrivate *priv = GET_PRIV (app);
+
+    priv->cmd_hash = NULL;
+
+    if (!g_file_test (GOOROOM_PATH, G_FILE_TEST_EXISTS))
+        return;
+
+    priv->cmd_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+    if ((fp = g_fopen (GOOROOM_PATH, "r")) != NULL)
+    {
+        while (fgets (line, sizeof (line), fp) != NULL)
+        {
+            int len = strlen (line);
+            if (len <= 1)
+                break;
+            line [len -1]= '\0';
+            lineptr = line;
+            cmds = g_strsplit (lineptr,",", -1);
+            g_hash_table_insert (priv->cmd_hash, g_strdup(cmds[0]), g_strdup(cmds[1]));
+        }
+        fclose (fp);
+    }
+
+    if (cmds)
+        g_strfreev (cmds);
+}
 
 static void
 yelp_application_init (YelpApplication *app)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     priv->docsettings = g_hash_table_new_full (g_str_hash, g_str_equal,
                                                (GDestroyNotify) g_free,
                                                (GDestroyNotify) g_object_unref);
-
     gtk_application_set_accels_for_action (GTK_APPLICATION (app),
                                            "app.yelp-application-show-cursor",
                                            (const gchar*[]) {"F7", NULL});
@@ -174,6 +214,8 @@ yelp_application_class_init (YelpApplicationClass *klass)
 
     object_class->dispose = yelp_application_dispose;
     object_class->finalize = yelp_application_finalize;
+
+    //g_type_class_add_private (klass, sizeof (YelpApplicationPrivate));
 }
 
 static void
@@ -187,7 +229,7 @@ yelp_application_iface_init (YelpBookmarksInterface *iface)
 static void
 yelp_application_dispose (GObject *object)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (YELP_APPLICATION (object));
+    YelpApplicationPrivate *priv = GET_PRIV (object);
 
     if (priv->show_cursor_action) {
         g_object_unref (priv->show_cursor_action);
@@ -209,13 +251,18 @@ yelp_application_dispose (GObject *object)
         priv->gsettings = NULL;
     }
 
+    if (priv->cmd_hash) {
+        g_hash_table_unref (priv->cmd_hash);
+        priv->cmd_hash = NULL;
+    }
+
     G_OBJECT_CLASS (yelp_application_parent_class)->dispose (object);
 }
 
 static void
 yelp_application_finalize (GObject *object)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (YELP_APPLICATION (object));
+    YelpApplicationPrivate *priv = GET_PRIV (object);
 
     g_hash_table_destroy (priv->windows_by_document);
     g_hash_table_destroy (priv->docsettings);
@@ -232,17 +279,49 @@ yelp_application_cmdline (GApplication     *app,
     GOptionContext *context;
     gint argc = g_strv_length (*arguments);
     gint i;
+    YelpApplication *yelp;
+    YelpApplicationPrivate *priv;
+
+    const gchar * const *langs = g_get_language_names ();
 
     context = g_option_context_new (NULL);
     g_option_context_add_group (context, gtk_get_option_group (FALSE));
     g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);
     g_option_context_parse (context, &argc, arguments, NULL);
 
+    //gooroom init
+    yelp = YELP_APPLICATION (app);
+    priv = GET_PRIV (app);
+    yelp_application_gooroom_init (yelp);
+
+    gint lang_i;
+    gboolean is_ko = FALSE;
+
+    for (lang_i = 0; langs[lang_i]; lang_i++) {
+        if (g_strcmp0 (langs[lang_i], "ko") == 0) {
+            is_ko = TRUE;
+            break;
+        }
+    }
+
+    if (is_ko && priv->cmd_hash &&
+        0 < g_hash_table_size (priv->cmd_hash)) {
+        for (i = 1; i < argc; i++) {
+            gchar *gr_cmd;
+            gr_cmd = g_hash_table_lookup (priv->cmd_hash, (*arguments)[i]);
+            if (gr_cmd != NULL) {
+                (*arguments)[i] = g_strdup (gr_cmd);
+            }
+        }
+    }
+#if 0
+    // local
     for (i = 1; i < argc; i++) {
         if (!strchr ((*arguments)[i], ':') && !((*arguments)[i][0] == '/')) {
             GFile *base, *new;
             gchar *cur, *newuri;
             cur = g_get_current_dir ();
+
             base = g_file_new_for_path (cur);
             new = g_file_resolve_relative_path (base, (*arguments)[i]);
             newuri = g_file_get_uri (new);
@@ -254,20 +333,43 @@ yelp_application_cmdline (GApplication     *app,
         }
     }
 
+#endif
     return G_APPLICATION_CLASS (yelp_application_parent_class)
         ->local_command_line (app, arguments, exit_status);
 }
 
+//static void
+//yelp_application_ui_init (YelpApplication *application)
+//{
+//    static gboolean initialized = FALSE;
+//    YelpApplicationPrivate *priv = GET_PRIV (application);
+//
+//    if (initialized)
+//        return;
+//
+//    initialized = TRUE;
+//
+//    priv->provider = gtk_css_provider_new ();
+//    gtk_style_context_add_provider_for_screen (gdk_screen_get_default (),
+//                    GTK_STYLE_PROVIDER (priv->provider),
+//                    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+//
+//    
+//}
+
 static void
 yelp_application_startup (GApplication *application)
 {
     YelpApplication *app = YELP_APPLICATION (application);
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     gchar *keyfile;
     YelpSettings *settings;
 
     g_set_application_name (_("Help"));
 
+    ///* initialize ui */
+    //yelp_application_ui_init (app);
+
     /* chain up */
     G_APPLICATION_CLASS (yelp_application_parent_class)->startup (application);
 
@@ -282,6 +384,7 @@ yelp_application_startup (GApplication *application)
                                                        g_str_equal,
                                                        g_free,
                                                        NULL);
+
     /* Use a config file for per-document settings, because
        Ryan asked me to. */
     keyfile = g_build_filename (g_get_user_config_dir (), "yelp", "yelp.cfg", NULL);
@@ -326,7 +429,7 @@ application_adjust_font (GAction         *action,
                          GVariant        *parameter,
                          YelpApplication *app)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     gint adjustment = g_settings_get_int (priv->gsettings, "font-adjustment");
     gint adjust = g_str_equal (g_action_get_name (action), "yelp-application-larger-text") ? 1 : -1;
 
@@ -339,7 +442,7 @@ application_adjust_font (GAction         *action,
 static void
 application_set_font_sensitivity (YelpApplication *app)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     YelpSettings *settings = yelp_settings_get_default ();
     GParamSpec *spec = g_object_class_find_property ((GObjectClass *) YELP_SETTINGS_GET_CLASS (settings),
                                                      "font-adjustment");
@@ -460,7 +563,7 @@ application_uri_resolved (YelpUri             *uri,
     YelpWindow *window;
     gchar *doc_uri;
     GdkWindow *gdk_window;
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (data->app);
+    YelpApplicationPrivate *priv = GET_PRIV (data->app);
     GFile *gfile;
 
     /* We held the application while resolving the URI, so unhold now. */
@@ -511,7 +614,6 @@ application_uri_resolved (YelpUri             *uri,
     else {
         g_free (doc_uri);
     }
-
     yelp_window_load_uri (window, uri);
 
     gtk_widget_show_all (GTK_WIDGET (window));
@@ -548,7 +650,7 @@ application_window_deleted (YelpWindow      *window,
                             YelpApplication *app)
 {
     gchar *doc_uri; /* owned by windows_by_document */
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
 
     priv->windows = g_slist_remove (priv->windows, window);
     doc_uri = g_object_get_data (G_OBJECT (window), "doc_uri");
@@ -561,7 +663,7 @@ application_window_deleted (YelpWindow      *window,
 GSettings *
 application_get_doc_settings (YelpApplication *app, const gchar *doc_uri)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     GSettings *settings = g_hash_table_lookup (priv->docsettings, doc_uri);
     if (settings == NULL) {
         gchar *tmp, *key, *settings_path;
@@ -759,7 +861,7 @@ static gboolean
 window_resized (YelpWindow        *window,
                 YelpApplication   *app)
 {
-    YelpApplicationPrivate *priv = yelp_application_get_instance_private (app);
+    YelpApplicationPrivate *priv = GET_PRIV (app);
     YelpUri *uri;
     gchar *doc_uri;
     GSettings *settings;
diff --git a/src/yelp-window.c b/src/yelp-window.c
index 5c85c8d..4a19574 100644
--- a/src/yelp-window.c
+++ b/src/yelp-window.c
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /*
- * Copyright (C) 2010-2020 Shaun McCance <shaunm@gnome.org>
+ * Copyright (C) 2010 Shaun McCance <shaunm@gnome.org>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -34,9 +34,16 @@
 #include "yelp-uri.h"
 #include "yelp-view.h"
 
+#include "yelp-help-list.h"
+
 #include "yelp-application.h"
 #include "yelp-window.h"
 
+typedef enum {
+    CURSOR_DEFAULT = 0,
+    CURSOR_POINTER,
+}CursorTypeEnum;
+
 static void          yelp_window_dispose          (GObject            *object);
 static void          yelp_window_finalize         (GObject            *object);
 static void          yelp_window_get_property     (GObject            *object,
@@ -48,6 +55,12 @@ static void          yelp_window_set_property     (GObject            *object,
                                                    const GValue       *value,
                                                    GParamSpec         *pspec);
 
+static void          window_set_toc_list               (YelpWindow *window);
+static void          yelp_window_toc_items_free         (TocItem *item);
+static gboolean      change_label_css                   (GtkWidget      *label,
+                                                         GtkCssProvider *css);
+static void          change_selection                   (gchar *id, YelpWindow *window);
+
 static void          window_construct             (YelpWindow         *window);
 
 static gboolean      window_map_event             (YelpWindow         *window,
@@ -69,6 +82,15 @@ static gboolean      window_key_press             (YelpWindow         *window,
                                                    GdkEventKey        *event,
                                                    gpointer            userdata);
 
+static gboolean      set_cursor                   (YelpWindow         *window,
+                                                   CursorTypeEnum     type);
+static gboolean      enter_side_button            (GtkButton          *button,
+                                                   GdkEvent           *event,
+                                                   gpointer            data);
+static gboolean      leave_side_button            (GtkButton          *button,
+                                                   GdkEvent           *event,
+                                                   gpointer            data);
+
 static void          bookmark_activated           (GtkListBox         *box,
                                                    GtkListBoxRow      *row,
                                                    YelpWindow         *window);
@@ -83,9 +105,9 @@ static void          app_bookmarks_changed        (YelpApplication    *app,
 static void          window_set_bookmarks         (YelpWindow         *window,
                                                    const gchar        *doc_uri);
 static void          window_set_bookmark_buttons  (YelpWindow         *window);
-static void          window_search_mode           (GtkSearchBar       *search_bar,
-                                                   GParamSpec         *pspec,
-                                                   YelpWindow         *window);
+//static void          window_search_mode           (GtkSearchBar       *search_bar,
+//                                                   GParamSpec         *pspec,
+//                                                   YelpWindow         *window);
 
 static void          action_new_window            (GSimpleAction      *action,
                                                    GVariant           *parameter,
@@ -161,7 +183,6 @@ struct _YelpWindowPrivate {
     GtkWidget *header;
     GtkWidget *vbox_view;
     GtkWidget *vbox_full;
-    GtkWidget *search_bar;
     GtkWidget *search_entry;
     GtkWidget *find_bar;
     GtkWidget *find_entry;
@@ -170,7 +191,22 @@ struct _YelpWindowPrivate {
     GtkWidget *bookmark_list;
     GtkWidget *bookmark_add;
     GtkWidget *bookmark_remove;
-    YelpView *view;
+    YelpView  *view;
+
+    GtkWidget *hbox_main;
+    GtkWidget *vbox_side;
+    GtkWidget *scrolled_wnd;
+    GtkWidget *bbox_toc;
+
+    GtkWidget   *vbox_content;
+    GtkWidget   *stack;
+    GList       *toc_items;
+    GdkCursor   *default_cursor;
+    GdkCursor   *pointer_cursor;
+
+    GtkCssProvider *css;
+    GtkCssProvider *highlight_css;
+    GtkCssProvider *default_css;
 
     GtkWidget *ctrll_entry;
 
@@ -184,6 +220,7 @@ struct _YelpWindowPrivate {
 };
 
 G_DEFINE_TYPE_WITH_PRIVATE (YelpWindow, yelp_window, HDY_TYPE_APPLICATION_WINDOW)
+#define GET_PRIV(object)(G_TYPE_INSTANCE_GET_PRIVATE ((object), YELP_TYPE_WINDOW, YelpWindowPrivate))
 
 static void
 yelp_window_init (YelpWindow *window)
@@ -219,12 +256,14 @@ yelp_window_class_init (YelpWindowClass *klass)
                       0, NULL, NULL,
                       g_cclosure_marshal_VOID__VOID,
                       G_TYPE_NONE, 0);
+
+    //g_type_class_add_private (klass, sizeof (YelpWindowPrivate));
 }
 
 static void
 yelp_window_dispose (GObject *object)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (YELP_WINDOW (object));
+    YelpWindowPrivate *priv = GET_PRIV (object);
 
     if (priv->bookmarks_changed) {
         g_signal_handler_disconnect (priv->application, priv->bookmarks_changed);
@@ -236,14 +275,24 @@ yelp_window_dispose (GObject *object)
         priv->ctrll_entry = NULL;
     }
 
+    g_clear_object (&priv->default_cursor);
+    g_clear_object (&priv->pointer_cursor);
+
     G_OBJECT_CLASS (yelp_window_parent_class)->dispose (object);
 }
 
 static void
 yelp_window_finalize (GObject *object)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (YELP_WINDOW (object));
+    YelpWindowPrivate *priv = GET_PRIV (object);
+
     g_free (priv->doc_uri);
+    g_list_free_full (priv->toc_items, (GDestroyNotify) yelp_window_toc_items_free);
+
+    g_object_unref (priv->css);
+    g_object_unref (priv->highlight_css);
+    g_object_unref (priv->default_css);
+
     G_OBJECT_CLASS (yelp_window_parent_class)->finalize (object);
 }
 
@@ -253,7 +302,7 @@ yelp_window_get_property (GObject    *object,
                           GValue     *value,
                           GParamSpec *pspec)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (YELP_WINDOW (object));
+    YelpWindowPrivate *priv = GET_PRIV (object);
     switch (prop_id) {
     case PROP_APPLICATION:
         g_value_set_object (value, priv->application);
@@ -270,11 +319,12 @@ yelp_window_set_property (GObject     *object,
                           const GValue *value,
                           GParamSpec   *pspec)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (YELP_WINDOW (object));
+    YelpWindowPrivate *priv = GET_PRIV (object);
     switch (prop_id) {
     case PROP_APPLICATION:
         priv->application = g_value_get_object (value);
         window_construct ((YelpWindow *) object);
+        //window_set_toc ((YelpWindow *) object);
         break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -282,6 +332,163 @@ yelp_window_set_property (GObject     *object,
     }
 }
 
+static gboolean
+change_label_css (GtkWidget      *label,
+                  GtkCssProvider *css)
+{
+     if (css == NULL)
+        return FALSE;
+
+    gtk_style_context_add_provider (gtk_widget_get_style_context (label),
+        GTK_STYLE_PROVIDER (css),
+        GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+
+    return TRUE;
+}
+
+static void
+change_selection (gchar *id, YelpWindow *window)
+{
+    YelpWindowPrivate *priv = GET_PRIV (window);
+    GtkAdjustment *adj = NULL;
+    GtkListBoxRow *row = NULL;
+
+    for (GList *l = g_list_first (priv->toc_items); l != NULL; l = l->next) {
+        TocItem *item = (TocItem*)l->data;
+
+        if (!g_strcmp0 (id, item->id)) {
+            item->checked = TRUE;
+            gtk_list_box_select_row (GTK_LIST_BOX(priv->bbox_toc), GTK_LIST_BOX_ROW (item->row));
+            change_label_css (item->label, priv->highlight_css);
+        }
+        else {
+            if (!item->checked)
+                continue;
+
+            item->checked = FALSE;
+            gtk_list_box_unselect_row (GTK_LIST_BOX(priv->bbox_toc), GTK_LIST_BOX_ROW (item->row));
+            change_label_css (item->label, priv->default_css);
+        }
+    }
+
+    /* scolled to selected row */
+    row = gtk_list_box_get_selected_row (GTK_LIST_BOX (priv->bbox_toc));
+    if (row != NULL) {
+        gint y;
+        gtk_widget_translate_coordinates (GTK_WIDGET (row), priv->bbox_toc, 0, 0, NULL, &y);
+        {
+//            gint height;
+            adj = gtk_list_box_get_adjustment (GTK_LIST_BOX (priv->bbox_toc));
+//            gtk_widget_get_preferred_height (GTK_WIDGET (row), NULL, &height);
+//            height = gtk_widget_get_allocated_height (GTK_WIDGET (row));
+            gtk_adjustment_set_value (adj, y);
+        }
+    }
+}
+
+static void
+yelp_window_clicked_toc (GtkButton *button, gpointer data)
+{
+    TocItem *sel_item = (TocItem*)data;
+    YelpWindow *window = sel_item->window;
+    YelpWindowPrivate *priv = GET_PRIV (window);
+
+    change_selection (sel_item->id, window);
+    
+    yelp_view_load (priv->view, sel_item->id);
+}
+
+static void
+yelp_window_toc_items_free (TocItem *item)
+{
+    g_free (item->title);
+    g_free (item->id);
+    g_free (item);
+}
+
+static void
+window_set_toc_list (YelpWindow *window)
+{
+    YelpWindowPrivate *priv = GET_PRIV (window);
+    YelpUri *uri = yelp_uri_new ("help-list:");
+    YelpDocument *document = NULL;
+    GList *entries = NULL;
+    GList *cur = NULL;
+
+    document = yelp_help_list_new (uri);
+    help_list_entries_init ((YelpHelpList *)document);
+    entries = help_list_get_all_entries (document);
+
+    /* hover & check css for label */
+      priv->highlight_css = gtk_css_provider_new ();
+      gtk_css_provider_load_from_data (priv->highlight_css,
+".vbox-side-button-label {"
+"   font-family: NotoSansCJKkr;"
+"   font-size: 13px;"
+"   font-weight: normal;"
+"   font-style: normal;"
+"   color: #1b6ed0;"
+"}"
+, -1, NULL);
+
+      priv->default_css = gtk_css_provider_new ();
+      gtk_css_provider_load_from_data (priv->default_css,
+".vbox-side-button-label {"
+"   font-family: NotoSansCJKkr;"
+"   font-size: 13px;"
+"   font-weight: normal;"
+"   font-style: normal;"
+"   color: #000000;"
+"}"
+, -1, NULL);
+
+    /*  */
+    for (cur = entries; cur != NULL; cur = cur->next) {
+        HelpListEntry *entry = (HelpListEntry *) cur->data;
+        gchar *title         = entry->title ? g_strdup (entry->title) : (strchr (entry->id, ':') + 1);
+        TocItem *item        = g_new0 (TocItem, 1);
+        GtkWidget *button    = gtk_toggle_button_new ();
+        GtkWidget *label     = gtk_label_new (title);
+        GtkWidget *row       = gtk_list_box_row_new ();
+
+        /* set style class name */
+        gtk_style_context_add_class (gtk_widget_get_style_context (button),
+                                     "vbox-side-button");
+        gtk_style_context_add_class (gtk_widget_get_style_context (label),
+                                     "vbox-side-button-label");
+        gtk_style_context_add_class (gtk_widget_get_style_context (row),
+                                     "toc-list-row");
+
+        /* set label property*/
+        gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
+        gtk_widget_set_halign (label, GTK_ALIGN_START);
+        //gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
+
+        /* layout */
+        gtk_container_add (GTK_CONTAINER (button), label);
+        gtk_container_add (GTK_CONTAINER (row), button);
+        gtk_list_box_prepend (GTK_LIST_BOX (priv->bbox_toc), row);
+
+        /* set toc item */
+        item->title = g_strdup (title);
+        item->id = g_strdup (entry->id);
+        item->window = window;
+        item->button = button;
+        item->row    = row;
+        item->label = label;
+        item->checked = FALSE;
+
+        /* add in toc item list */
+        priv->toc_items = g_list_prepend (priv->toc_items, item);
+
+        g_signal_connect (button, "clicked", G_CALLBACK (yelp_window_clicked_toc), item);
+        g_signal_connect (button, "enter-notify-event", G_CALLBACK (enter_side_button), item);
+        g_signal_connect (button, "leave-notify-event", G_CALLBACK (leave_side_button), item);
+    }
+
+    g_object_unref (uri);
+}
+
 static gboolean
 window_button_press (YelpWindow *window, GdkEventButton *event, gpointer userdata)
 {
@@ -322,6 +529,51 @@ window_construct (YelpWindow *window)
         { "yelp-window-ctrll",  action_ctrll,        NULL, NULL, NULL },
     };
 
+    /* CSS Provider */
+    priv->css = gtk_css_provider_new ();
+    gtk_css_provider_load_from_data (priv->css,
+".yelp-find-frame {"
+"   background-color: @theme_base_color;"
+"   padding: 6px;"
+"   border-color: @borders;"
+"   border-radius: 0 0 3px 3px;"
+"   border-width: 0 1px 1px 1px;"
+"   border-style: solid;"
+"}"
+".bbox-toc {"
+"	background-color: rgba(0,0,0,0.0);"
+"}"
+".toc-list-row {"
+"   padding-top: 5px;"
+"   padding-bottom: 5px;"
+"	background-color: rgba(0,0,0,0.0);"
+"}"
+".toc-list-row:activate {"
+"	background-color: rgba(201,201,201,0.0);"
+"}"
+".vbox-side {"
+"	background-color: rgba(0,0,0,0.0);"
+"}"
+".vbox-side-button {"
+"	background-color: rgba(201,201,201,0.0);"
+"   border: none;"
+"   border-radius: 6px;"
+"}"
+".vbox-side-button:hover {"
+"	color: rgba(27,110,208,0.6);"
+"}"
+".vbox-side-button-label {"
+"   font-family: NotoSansCJKkr;"
+"   font-size: 13px;"
+"   font-weight: normal;"
+"   font-style: normal;"
+"   color: #000000;"
+"}"
+,-1, NULL);
+    gtk_style_context_add_provider_for_screen (gdk_screen_get_default (),
+                                    GTK_STYLE_PROVIDER (priv->css),
+                                    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+
     gtk_window_set_icon_name (GTK_WINDOW (window), "org.gnome.Yelp");
 
     priv->view = (YelpView *) yelp_view_new ();
@@ -391,16 +643,24 @@ window_construct (YelpWindow *window)
 
     gtk_menu_button_set_menu_model (GTK_MENU_BUTTON (button), G_MENU_MODEL (menu));
 
+    /** Frame **/
+    priv->hbox_main = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+    gtk_box_pack_start (GTK_BOX (priv->vbox_full), priv->hbox_main, TRUE, TRUE, 0);
+
+    priv->vbox_side = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+    gtk_style_context_add_class (gtk_widget_get_style_context (priv->vbox_side),
+                                 "vbox-side");
+    gtk_widget_set_size_request (priv->vbox_side, 215, -1);
+
+    gtk_box_pack_start (GTK_BOX (priv->hbox_main), priv->vbox_side, FALSE, FALSE, 0);
+
     /** Search **/
-    priv->vbox_view = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
-    gtk_box_pack_start (GTK_BOX (priv->vbox_full), priv->vbox_view, TRUE, TRUE, 0);
+    //priv->vbox_view = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+    //gtk_box_pack_start (GTK_BOX (priv->vbox_full), priv->vbox_view, TRUE, TRUE, 0);
 
-    priv->search_bar = gtk_search_bar_new ();
-    gtk_box_pack_start (GTK_BOX (priv->vbox_view), priv->search_bar, FALSE, FALSE, 0);
     priv->search_entry = yelp_search_entry_new (priv->view,
                                                 YELP_BOOKMARKS (priv->application));
     gtk_entry_set_width_chars (GTK_ENTRY (priv->search_entry), 50);
-    gtk_container_add (GTK_CONTAINER (priv->search_bar), priv->search_entry);
     button = gtk_toggle_button_new ();
     gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
     gtk_style_context_add_class (gtk_widget_get_style_context (button), "image-button");
@@ -408,15 +668,41 @@ window_construct (YelpWindow *window)
                           gtk_image_new_from_icon_name ("edit-find-symbolic",
                                                         GTK_ICON_SIZE_MENU));
     gtk_widget_set_tooltip_text (button, _("Search (Ctrl+S)"));
-    g_object_bind_property (button, "active",
-                            priv->search_bar, "search-mode-enabled",
-                            G_BINDING_BIDIRECTIONAL);
-    g_signal_connect (priv->search_bar, "notify::search-mode-enabled",
-                      G_CALLBACK (window_search_mode), window);
-    hdy_header_bar_pack_end (HDY_HEADER_BAR (priv->header), button);
+    //g_object_bind_property (button, "active",
+    //                        priv->search_bar, "search-mode-enabled",
+    //                        G_BINDING_BIDIRECTIONAL);
+    //g_signal_connect (priv->search_bar, "notify::search-mode-enabled",
+    //                  G_CALLBACK (window_search_mode), window);
+    //hdy_header_bar_pack_end (HDY_HEADER_BAR (priv->header), button);
 
     g_signal_connect (window, "key-press-event", G_CALLBACK (window_key_press), NULL);
 
+    /* Side box scrolled window */
+    priv->scrolled_wnd = gtk_scrolled_window_new (NULL, NULL);
+    gtk_box_pack_end (GTK_BOX (priv->vbox_side), priv->scrolled_wnd, TRUE, TRUE, 0);
+
+//    priv->bbox_toc = gtk_box_new (GTK_ORIENTATION_VERTICAL, 15);
+//    gtk_widget_set_margin_start (priv->bbox_toc, 10);
+//    gtk_widget_set_margin_end (priv->bbox_toc, 15);
+//    gtk_widget_set_margin_top (priv->bbox_toc, 20);
+//    gtk_widget_set_margin_bottom (priv->bbox_toc, 20);
+//    gtk_container_add (GTK_CONTAINER (priv->scrolled_wnd), GTK_WIDGET (priv->bbox_toc));
+    priv->bbox_toc = gtk_list_box_new ();
+
+
+    gtk_style_context_add_class (gtk_widget_get_style_context (priv->bbox_toc),
+                                 "bbox-toc");
+
+    gtk_widget_set_margin_start (priv->bbox_toc, 10);
+    gtk_widget_set_margin_end (priv->bbox_toc, 15);
+    gtk_widget_set_margin_top (priv->bbox_toc, 10);
+    gtk_widget_set_margin_bottom (priv->bbox_toc, 10);
+    gtk_container_add (GTK_CONTAINER (priv->scrolled_wnd), GTK_WIDGET (priv->bbox_toc));
+
+    /* Table of contents */
+    priv->vbox_view = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
+    gtk_box_pack_end (GTK_BOX (priv->hbox_main), priv->vbox_view, TRUE, TRUE, 0);
+    window_set_toc_list ((YelpWindow *) window);
     /** Bookmarks **/
     button = gtk_menu_button_new ();
     gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
@@ -433,6 +719,7 @@ window_construct (YelpWindow *window)
 
     box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
     gtk_container_add (GTK_CONTAINER (priv->bookmark_menu), box);
+    gtk_widget_hide (priv->bookmark_menu);
     priv->bookmark_sw = gtk_scrolled_window_new (NULL, NULL);
     gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (priv->bookmark_sw),
                                     GTK_POLICY_NEVER,
@@ -466,26 +753,13 @@ window_construct (YelpWindow *window)
                           G_CALLBACK (app_bookmarks_changed), window);
 
     /** Find **/
-    css = gtk_css_provider_new ();
+    //css = gtk_css_provider_new ();
     /* FIXME: Connect to parsing-error signal. */
-    gtk_css_provider_load_from_data (css,
-                                     ".yelp-find-frame {"
-                                     "    background-color: @theme_base_color;"
-                                     "    padding: 6px;"
-                                     "    border-color: @borders;"
-                                     "    border-radius: 0 0 3px 3px;"
-                                     "    border-width: 0 1px 1px 1px;"
-                                     "    border-style: solid;"
-                                     "}",
-                                     -1, NULL);
     priv->find_bar = gtk_revealer_new ();
     frame = gtk_frame_new (NULL);
     gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
     gtk_style_context_add_class (gtk_widget_get_style_context (frame),
                                  "yelp-find-frame");
-    gtk_style_context_add_provider (gtk_widget_get_style_context (frame),
-                                    GTK_STYLE_PROVIDER (css),
-                                    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
     box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
     g_object_set (priv->find_bar,
                   "halign", GTK_ALIGN_END,
@@ -496,8 +770,6 @@ window_construct (YelpWindow *window)
     gtk_container_add (GTK_CONTAINER (frame), box);
     gtk_container_add (GTK_CONTAINER (priv->find_bar), frame);
 
-    g_object_unref (css);
-
     size_group = gtk_size_group_new (GTK_SIZE_GROUP_VERTICAL);
 
     priv->find_entry = gtk_search_entry_new ();
@@ -528,9 +800,14 @@ window_construct (YelpWindow *window)
     /** View **/
     box = gtk_overlay_new ();
     gtk_overlay_add_overlay (GTK_OVERLAY (box), GTK_WIDGET (priv->find_bar));
+//    gtk_widget_set_margin_start (box, 15);
+//    gtk_widget_set_margin_end (box, 30);
+//    gtk_widget_set_margin_top (box, 20);
+//    gtk_widget_set_margin_bottom (box, 20);
 
     gtk_container_add (GTK_CONTAINER (box), GTK_WIDGET (priv->view));
     gtk_box_pack_start (GTK_BOX (priv->vbox_view), box, TRUE, TRUE, 0);
+    //gtk_box_pack_start (GTK_BOX (priv->vbox_view), GTK_WIDGET (priv->view), TRUE, TRUE, 0);
 
     g_signal_connect (priv->view, "new-view-requested", G_CALLBACK (view_new_window), window);
     g_signal_connect (priv->view, "loaded", G_CALLBACK (view_loaded), window);
@@ -569,8 +846,7 @@ void
 yelp_window_load_uri (YelpWindow  *window,
                       YelpUri     *uri)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
-
+    YelpWindowPrivate *priv = GET_PRIV (window);
     yelp_view_load_uri (priv->view, uri);
 }
 
@@ -578,7 +854,7 @@ YelpUri *
 yelp_window_get_uri (YelpWindow *window)
 {
     YelpUri *uri;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     g_object_get (G_OBJECT (priv->view), "yelp-uri", &uri, NULL);
     return uri;
 }
@@ -588,7 +864,7 @@ yelp_window_get_geometry (YelpWindow  *window,
                           gint        *width,
                           gint        *height)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     *width = priv->width;
     *height = priv->height;
 }
@@ -603,7 +879,7 @@ action_new_window (GSimpleAction *action,
     YelpUri *yuri;
     gchar *uri = NULL;
     YelpWindow *window = YELP_WINDOW (userdata);
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (priv->view, "yelp-uri", &yuri, NULL);
     uri = yelp_uri_get_document_uri (yuri);
@@ -627,10 +903,10 @@ action_search (GSimpleAction *action,
                GVariant      *parameter,
                gpointer       userdata)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (userdata);
+    YelpWindowPrivate *priv = GET_PRIV (userdata);
 
     gtk_revealer_set_reveal_child (GTK_REVEALER (priv->find_bar), FALSE);
-    gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), TRUE);
+    //gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), TRUE);
     gtk_widget_grab_focus (priv->search_entry);
 }
 
@@ -639,9 +915,9 @@ action_find (GSimpleAction *action,
              GVariant      *parameter,
              gpointer       userdata)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (userdata);
+    YelpWindowPrivate *priv = GET_PRIV (userdata);
 
-    gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
+    //gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
     gtk_revealer_set_reveal_child (GTK_REVEALER (priv->find_bar), TRUE);
     gtk_widget_grab_focus (priv->find_entry);
 }
@@ -651,7 +927,7 @@ action_go_all (GSimpleAction *action,
                GVariant      *parameter,
                gpointer       userdata)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (userdata);
+    YelpWindowPrivate *priv = GET_PRIV (userdata);
     yelp_view_load (priv->view, "help-list:");
 }
 
@@ -660,7 +936,7 @@ action_ctrll (GSimpleAction *action,
               GVariant      *parameter,
               gpointer       userdata)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (userdata);
+    YelpWindowPrivate *priv = GET_PRIV (userdata);
     YelpUri *yuri;
     gchar *uri = NULL;
 
@@ -728,7 +1004,7 @@ window_map_event (YelpWindow  *window,
                   GdkEvent    *event,
                   gpointer     user_data)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     priv->configured = TRUE;
     return FALSE;
 }
@@ -738,7 +1014,7 @@ window_configure_event (YelpWindow         *window,
                         GdkEventConfigure  *event,
                         gpointer            user_data)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     gboolean skip = TRUE;
     if (priv->width != event->width) {
         skip = FALSE;
@@ -767,7 +1043,7 @@ window_configure_event (YelpWindow         *window,
 static gboolean
 window_resize_signal (YelpWindow *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     g_signal_emit (window, signals[RESIZE_EVENT], 0);
     priv->resize_signal = 0;
     return FALSE;
@@ -786,8 +1062,71 @@ window_key_press (YelpWindow  *window,
     if (hdy_header_bar_get_custom_title (HDY_HEADER_BAR (priv->header)))
         return FALSE;
 
-    return gtk_search_bar_handle_event (GTK_SEARCH_BAR (priv->search_bar),
-                                        (GdkEvent *) event);
+	return FALSE;
+    //return gtk_search_bar_handle_event (GTK_SEARCH_BAR (priv->search_bar),
+    //                                    (GdkEvent *) event);
+}
+
+static gboolean
+set_cursor (YelpWindow *window, CursorTypeEnum type)
+{
+    GdkCursor *cursor = NULL;
+    YelpWindowPrivate *priv = GET_PRIV (window);
+
+    switch (type) {
+        case CURSOR_DEFAULT:
+            cursor = priv->default_cursor;
+        break;
+        case CURSOR_POINTER:
+            cursor = priv->pointer_cursor;
+        break;
+        default:
+            return TRUE;
+        break;
+    }
+    gdk_window_set_cursor (gtk_widget_get_window (GTK_WIDGET (window)), cursor);
+
+    return FALSE;
+}
+
+static gboolean
+enter_side_button (GtkButton *button,
+                   GdkEvent *event,
+                   gpointer data)
+{
+    TocItem *item = (TocItem*)data;
+    YelpWindowPrivate *priv = GET_PRIV (item->window);
+
+    if (item->checked)
+        goto bail;
+
+    if (!change_label_css (item->label, priv->highlight_css))
+        return FALSE;
+
+bail:
+    return set_cursor ((YelpWindow *)item->window, CURSOR_POINTER);
+}
+
+static gboolean
+leave_side_button (GtkButton *button,
+                   GdkEvent *event,
+                   gpointer data)
+{
+    TocItem *item = (TocItem*)data;
+    YelpWindowPrivate *priv = GET_PRIV (item->window);
+
+    if (item->checked)
+        goto bail;
+
+    if (!change_label_css (item->label, priv->default_css))
+        return FALSE;
+
+    gtk_style_context_add_provider (gtk_widget_get_style_context (item->label),
+        GTK_STYLE_PROVIDER (priv->default_css),
+        GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+
+bail:
+    return set_cursor ((YelpWindow *)item->window, CURSOR_DEFAULT);
 }
 
 static void
@@ -797,7 +1136,7 @@ bookmark_activated (GtkListBox    *box,
 {
     YelpUri *base, *uri;
     gchar *xref;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     gtk_widget_hide (priv->bookmark_menu);
 
@@ -821,7 +1160,7 @@ bookmark_removed (GtkButton  *button,
     YelpUri *uri;
     gchar *doc_uri;
     gchar *page_id = NULL;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (priv->view, "yelp-uri", &uri, NULL);
     doc_uri = yelp_uri_get_document_uri (uri);
@@ -850,7 +1189,7 @@ bookmark_added (GtkButton  *button,
 {
     YelpUri *uri;
     gchar *doc_uri, *page_id, *icon, *title;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (priv->view,
                   "yelp-uri", &uri,
@@ -875,7 +1214,7 @@ app_bookmarks_changed (YelpApplication *app,
 {
     YelpUri *uri;
     gchar *this_doc_uri;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (priv->view, "yelp-uri", &uri, NULL);
     this_doc_uri = yelp_uri_get_document_uri (uri);
@@ -919,7 +1258,7 @@ window_set_bookmarks (YelpWindow  *window,
     GVariant *value;
     GVariantIter *iter;
     gchar *page_id, *icon, *title;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     GList *children, *cur;
     GSList *entries = NULL;
 
@@ -979,7 +1318,7 @@ window_set_bookmark_buttons (YelpWindow *window)
     YelpUri *uri = NULL;
     gchar *doc_uri = NULL, *page_id = NULL;
     gboolean bookmarked;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
 
     g_object_get (priv->view,
@@ -1005,23 +1344,23 @@ window_set_bookmark_buttons (YelpWindow *window)
         g_object_unref (uri);
 }
 
-static void
-window_search_mode (GtkSearchBar  *search_bar,
-                    GParamSpec    *pspec,
-                    YelpWindow    *window)
-{
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
-
-    if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (search_bar)))
-        gtk_revealer_set_reveal_child (GTK_REVEALER (priv->find_bar), FALSE);
-}
+//static void
+//window_search_mode (GtkSearchBar  *search_bar,
+//                    GParamSpec    *pspec,
+//                    YelpWindow    *window)
+//{
+//    YelpWindowPrivate *priv = GET_PRIV (window);
+//
+//    if (gtk_search_bar_get_search_mode (GTK_SEARCH_BAR (search_bar)))
+//        gtk_revealer_set_reveal_child (GTK_REVEALER (priv->find_bar), FALSE);
+//}
 
 static gboolean
 find_entry_key_press (GtkEntry    *entry,
                       GdkEventKey *event,
                       YelpWindow  *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     WebKitFindController *find_controller;
 
     find_controller = webkit_web_view_get_find_controller (WEBKIT_WEB_VIEW (priv->view));
@@ -1046,7 +1385,7 @@ find_entry_changed (GtkEntry   *entry,
                     YelpWindow *window)
 {
     gchar *text;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     WebKitFindController *find_controller;
 
     find_controller = webkit_web_view_get_find_controller (WEBKIT_WEB_VIEW (priv->view));
@@ -1064,7 +1403,7 @@ static void
 find_prev_clicked (GtkButton  *button,
                    YelpWindow *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     WebKitFindController *find_controller;
 
     find_controller = webkit_web_view_get_find_controller (WEBKIT_WEB_VIEW (priv->view));
@@ -1075,7 +1414,7 @@ static void
 find_next_clicked (GtkButton  *button,
                    YelpWindow *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     WebKitFindController *find_controller;
 
     find_controller = webkit_web_view_get_find_controller (WEBKIT_WEB_VIEW (priv->view));
@@ -1087,7 +1426,7 @@ view_new_window (YelpView   *view,
                  YelpUri    *uri,
                  YelpWindow *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     yelp_application_new_window_uri (priv->application, uri);
 }
 
@@ -1099,7 +1438,7 @@ view_loaded (YelpView   *view,
     YelpUri *uri;
     gchar *doc_uri;
     YelpViewState state;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+//    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (view,
                   "yelp-uri", &uri,
@@ -1114,14 +1453,16 @@ view_loaded (YelpView   *view,
                       "page-icon", &icon,
                       "page-title", &title,
                       NULL);
-        if (!g_str_has_prefix (page_id, "search=")) {
-            gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
-        }
-        yelp_application_update_bookmarks (priv->application,
-                                           doc_uri,
-                                           page_id,
-                                           icon,
-                                           title);
+
+        change_selection (doc_uri, window);
+//        if (!g_str_has_prefix (page_id, "search=")) {
+//            gtk_search_bar_set_search_mode (GTK_SEARCH_BAR (priv->search_bar), FALSE);
+//        }
+//        yelp_application_update_bookmarks (priv->application,
+//                                           doc_uri,
+//                                           page_id,
+//                                           icon,
+//                                           title);
         g_free (page_id);
         g_free (icon);
         g_free (title);
@@ -1158,7 +1499,7 @@ view_uri_selected (YelpView     *view,
 {
     YelpUri *uri;
     gchar *doc_uri;
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     g_object_get (G_OBJECT (view), "yelp-uri", &uri, NULL);
     if (uri == NULL)
@@ -1201,7 +1542,7 @@ static void
 ctrll_entry_activate (GtkEntry    *entry,
                       YelpWindow  *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
     YelpUri *uri = yelp_uri_new (gtk_entry_get_text (entry));
 
     yelp_window_load_uri (window, uri);
@@ -1215,7 +1556,7 @@ ctrll_entry_key_press (GtkWidget    *widget,
                        GdkEventKey  *event,
                        YelpWindow   *window)
 {
-    YelpWindowPrivate *priv = yelp_window_get_instance_private (window);
+    YelpWindowPrivate *priv = GET_PRIV (window);
 
     if (event->keyval == GDK_KEY_Escape) {
         hdy_header_bar_set_custom_title (HDY_HEADER_BAR (priv->header), NULL);
diff --git a/src/yelp-window.h b/src/yelp-window.h
index 5b56250..24eef44 100644
--- a/src/yelp-window.h
+++ b/src/yelp-window.h
@@ -45,6 +45,16 @@ struct _YelpWindowClass
     HdyApplicationWindowClass  parent_class;
 };
 
+typedef struct _tocItem {
+    YelpWindow *window;
+    GtkWidget  *button;
+    GtkWidget  *label;
+    GtkWidget  *row;
+    gchar      *title;
+    gchar      *id;
+    gboolean    checked;
+}TocItem;
+
 GType             yelp_window_get_type     (void);
 YelpWindow *      yelp_window_new          (YelpApplication *app);
 void              yelp_window_load_uri     (YelpWindow      *window,
